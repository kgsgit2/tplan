<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Timeplanbox Pro V2 - Travel Schedule Studio</title>
    <!-- Google Material Icons -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Outlined" rel="stylesheet">
    
    <!-- Kakao Map API는 동적으로 로드합니다 -->
    
    <style>
        /* Google Material Design Color Scheme */
        :root {
            --md-green: #4CAF50;
            --md-blue: #2196F3;
            --md-purple: #9C27B0;
            --md-orange: #FF9800;
            --md-pink: #E91E63;
            --md-deep-purple: #673AB7;
            --md-primary: #1976D2;
            --md-grey: #9E9E9E;
            --md-light-grey: #F5F5F5;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f8f9fa;
            color: #212529;
            overflow: hidden;
            user-select: none;
        }
        
        /* 뷰 모드 클래스 - 추후 사용 예정 */
        /* body.edit-mode { } */
        /* body.compress-mode { } */
        /* body.print-mode { } */
        
        /* 헤더 */
        .header {
            height: 56px;
            background: #fff;
            border-bottom: 2px solid #e9ecef;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
        }
        
        .header-logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .header-logo h1 {
            font-size: 18px;
            font-weight: 700;
            color: #495057;
            letter-spacing: -0.5px;
        }
        
        .logo-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 16px;
        }
        
        .header-controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }
        
        .header-controls input {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            color: #495057;
            padding: 8px 14px;
            font-size: 14px;
            border-radius: 8px;
            transition: all 0.2s;
            font-weight: 500;
        }
        
        .header-controls input:focus {
            outline: none;
            border-color: #667eea;
            background: #fff;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        /* 뷰 모드 토글 버튼 그룹 */
        .view-mode-toggle {
            display: flex;
            gap: 0;
            background: #f8f9fa;
            padding: 2px;
            border-radius: 8px;
            border: 2px solid #e9ecef;
        }
        
        .view-mode-btn {
            background: transparent;
            color: #868e96;
            border: none;
            padding: 8px 16px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 6px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .view-mode-btn:hover {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
        }
        
        .view-mode-btn.active {
            background: #667eea;
            color: #fff;
        }
        
        .btn-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            border: none;
            padding: 10px 20px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }
        
        .btn-header:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .btn-print {
            background: linear-gradient(135deg, #20c997 0%, #12b886 100%);
            color: #fff;
            border: none;
            padding: 10px 20px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(32, 201, 151, 0.3);
        }

        .btn-print:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(32, 201, 151, 0.4);
        }
        
        /* 메인 레이아웃 */
        .main-layout {
            display: grid;
            grid-template-columns: 1fr 240px; /* 우측 패널 더 줄여서 타임라인 공간 확보 */
            height: calc(100vh - 56px);
            background: #f8f9fa;
        }
        
        
        /* 타임라인 영역 */
        .timeline-area {
            background: #fff;
            overflow: auto;
            position: relative;
            margin: 16px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
        }
        
        body.compress-mode .timeline-area,
        body.print-mode .timeline-area {
            margin: 8px;
        }
        
        .timeline-container {
            display: flex;
            min-width: fit-content;
            position: relative;
            padding-bottom: 20px;
        }
        
        /* 시간 라벨 */
        .time-labels {
            width: 70px;
            position: sticky;
            left: 0;
            background: #fff;
            z-index: 15;
            border-right: 2px solid #e9ecef;
            padding-top: 48px;
        }
        
        .time-label {
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;  /* 12px → 14px로 증가 */
            color: #495057;    /* 더 진한 색상으로 변경 */
            border-bottom: 1px solid #f1f3f5;
            position: relative;
            font-weight: 600;  /* 500 → 600으로 굵게 */
        }
        
        .time-label.hour {
            color: #495057;
            font-weight: 600;
            background: linear-gradient(90deg, #f8f9fa 0%, transparent 100%);
        }
        
        /* 시간 블록 그룹 */
        .time-label.dawn-block {
            background: #f3f0ff;
            color: #6c5ce7;
        }
        
        .time-label.morning-block {
            background: #fff3e0;
            color: #f57c00;
        }
        
        .time-label.afternoon-block {
            background: #e8f5e9;
            color: #2e7d32;
        }
        
        .time-label.evening-block {
            background: #fce4ec;
            color: #c2185b;
        }
        
        /* 압축 모드에서 빈 시간 숨김 */
        body.compress-mode .time-label.empty {
            height: 20px;
            opacity: 0.3;
        }
        
        body.compress-mode .time-slot.empty {
            height: 20px;
            background: repeating-linear-gradient(
                45deg,
                transparent,
                transparent 10px,
                #f8f9fa 10px,
                #f8f9fa 20px
            );
        }
        
        /* 날짜 컬럼 */
        .day-columns {
            display: flex;
        }
        
        .day-column {
            width: 150px;
            border-right: 1px solid #e9ecef;
            position: relative;
            background: #fff;
        }
        
        body.compress-mode .day-column,
        body.print-mode .day-column {
            width: 130px;
        }
        
        .day-header {
            height: 48px;
            background: linear-gradient(135deg, #f8f9fa 0%, #fff 100%);
            border-bottom: 2px solid #e9ecef;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
            color: #495057;
            font-weight: 700;
            position: sticky;
            top: 0;
            z-index: 10;
            letter-spacing: -0.3px;
        }
        
        .time-grid {
            position: relative;
        }
        
        .time-slot {
            height: 60px;
            border-bottom: 1px solid #f1f3f5;
            position: relative;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        /* 10분 단위 가이드라인 */
        .time-slot::before,
        .time-slot::after {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            height: 1px;
            background: #f8f9fa;
            pointer-events: none;
        }
        
        .time-slot::before {
            top: 33.33%;
        }
        
        .time-slot::after {
            top: 66.66%;
        }
        
        .time-slot:hover {
            background: rgba(102, 126, 234, 0.04);
        }
        
        .time-slot.drag-over {
            background: rgba(102, 126, 234, 0.1);
        }
        
        .time-slot.drag-over-10 {
            background: linear-gradient(to bottom, 
                rgba(102, 126, 234, 0.2) 0%, 
                rgba(102, 126, 234, 0.2) 16.66%, 
                transparent 16.66%);
        }
        
        .time-slot.drag-over-20 {
            background: linear-gradient(to bottom, 
                transparent 0%,
                transparent 16.66%,
                rgba(102, 126, 234, 0.2) 16.66%, 
                rgba(102, 126, 234, 0.2) 33.33%, 
                transparent 33.33%);
        }
        
        .time-slot.drag-over-30 {
            background: linear-gradient(to bottom, 
                transparent 0%,
                transparent 33.33%,
                rgba(102, 126, 234, 0.2) 33.33%, 
                rgba(102, 126, 234, 0.2) 50%, 
                transparent 50%);
        }
        
        .time-slot.drag-over-40 {
            background: linear-gradient(to bottom, 
                transparent 0%,
                transparent 50%,
                rgba(102, 126, 234, 0.2) 50%, 
                rgba(102, 126, 234, 0.2) 66.66%, 
                transparent 66.66%);
        }
        
        .time-slot.drag-over-50 {
            background: linear-gradient(to bottom, 
                transparent 0%,
                transparent 66.66%,
                rgba(102, 126, 234, 0.2) 66.66%, 
                rgba(102, 126, 234, 0.2) 83.33%, 
                transparent 83.33%);
        }
        
        .time-slot.drag-over-60 {
            background: linear-gradient(to bottom, 
                transparent 0%,
                transparent 83.33%,
                rgba(102, 126, 234, 0.2) 83.33%, 
                rgba(102, 126, 234, 0.2) 100%);
        }
        
        /* 플랜박스 영역 */
        .planbox-area {
            background: #fff;
            margin: 12px 12px 12px 0;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
            height: calc(100vh - 80px);
            overflow: hidden;
        }
        
        /* planbox-header 스타일 제거 - 더 이상 사용하지 않음 */
        
        .add-planbox-btn {
            width: 100%;
            padding: 12px;
            background: var(--md-primary);
            color: #fff;
            border: none;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12);
        }
        
        .add-planbox-btn:hover {
            background: #1565C0;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.16);
        }
        
        .planbox-list {
            flex: 1;
            overflow-y: auto;
            padding: 12px 10px;
            min-height: 0;
        }
        
        /* 플랜박스 아이템 */
        .planbox-item {
            background: #fff;
            border: 2px solid #e9ecef;
            margin-bottom: 10px;
            padding: 8px;
            cursor: move;
            position: relative;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            /* border-radius 제거 - 각진 모서리 */
            height: 60px;
            min-height: 60px;
            max-height: 60px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        
        .planbox-item:hover {
            border-color: #667eea;
            transform: translateX(-4px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.15);
        }
        
        .planbox-item:hover .planbox-controls {
            display: flex !important;
        }
        
        .planbox-item.dragging {
            opacity: 0.05;
        }
        
        /* 드래그 중 시간 표시 - 마우스 따라다니기 */
        /* 드래그 중 플랜박스 시간 강조 */
        .planbox-item.dragging .planbox-time {
            background: #ff4757;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            animation: timeUpdate 0.5s ease;
        }
        
        @keyframes timeUpdate {
            0% {
                background: #ff4757;
                transform: scale(1.1);
            }
            100% {
                background: #ff4757;
                transform: scale(1);
            }
        }
        
        .planbox-item.cloneable {
            border-style: dashed;
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.05);
        }
        
        /* 새벽 시간대 표시 */
        .planbox-item.dawn-time .planbox-time {
            background: #ffeaa7;
            color: #d63031;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 700;
        }
        
        .planbox-item.food {
            border-left: 5px solid #FF9800;
            background: linear-gradient(to right, rgba(255,152,0,0.08) 0%, white 50%);
        }
        
        .planbox-item.transport {
            border-left: 5px solid #4CAF50;
            background: linear-gradient(to right, rgba(76,175,80,0.08) 0%, white 50%);
        }
        
        .planbox-item.activity {
            border-left: 5px solid #2196F3;
            background: linear-gradient(to right, rgba(33,150,243,0.08) 0%, white 50%);
        }
        
        .planbox-item.sightseeing {
            border-left: 5px solid #9C27B0;
            background: linear-gradient(to right, rgba(156,39,176,0.08) 0%, white 50%);
        }
        
        .planbox-item.shopping {
            border-left: 5px solid #E91E63;
            background: linear-gradient(to right, rgba(233,30,99,0.08) 0%, white 50%);
        }
        
        .planbox-item.accommodation {
            border-left: 5px solid #673AB7;
            background: linear-gradient(to right, rgba(103,58,183,0.08) 0%, white 50%);
        }
        
        .planbox-time-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
        }
        
        .planbox-time {
            font-size: 12px;
            color: #212529;
            font-weight: 600;
        }

        .planbox-endtime {
            font-size: 11px;
            color: #667eea;
            font-weight: 600;
            margin-left: 8px;
        }
        
        .planbox-duration {
            font-size: 11px;
            background: #f8f9fa;
            color: #495057;
            padding: 2px 6px;
            font-weight: 600;
            border-radius: 4px;
        }
        
        .planbox-title {
            font-size: 15px;
            font-weight: 700;
            color: #212529;
            margin-bottom: 6px;
        }
        
        .planbox-info {
            display: none;  /* 타임존에서는 비용 숨김 */
            font-size: 13px;
            color: #212529;
            margin-bottom: 4px;
        }
        
        .planbox-memo {
            display: none;  /* 타임존에서는 메모 숨김 */
            font-size: 12px;
            color: #495057;
            overflow: hidden;
            -webkit-line-clamp: 2;
            line-clamp: 2;  /* 표준 속성 추가 */
            -webkit-box-orient: vertical;
            line-height: 1.4;
        }
        
        .planbox-controls {
            display: flex;
            gap: 4px;
        }
        
        .planbox-control {
            width: 28px;
            height: 28px;
            background: #f8f9fa;
            border: none;
            color: #495057;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            border-radius: 6px;
            font-size: 14px;
        }
        
        .planbox-control:hover {
            color: #212529;
            background: #e9ecef;
            transform: translateY(-1px);
        }
        
        .planbox-control.clone {
            font-weight: normal;
        }
        
        .planbox-control.clone.active {
            background: #667eea;
            color: white;
        }
        
        .planbox-control.clone.active .material-icons {
            color: white;
        }
        
        .planbox-control.delete:hover {
            color: #fff;
            background: #ff6b6b;
        }
        
        /* 배치된 박스 */
        .placed-box {
            position: absolute;
            left: 0;  /* 좌우 여백 제거 */
            right: 0;  /* 좌우 여백 제거 */
            background: #fff;
            border: none;  /* 모든 테두리 제거 */
            padding: 4px 8px;  /* 상하 패딩 줄여서 콘텐츠 공간 확보 */
            cursor: move;
            z-index: 5;
            transition: box-shadow 0.2s, transform 0.2s;
            overflow: hidden; /* 텍스트가 박스를 넘지 않도록 */
            /* border-radius 제거 - 각진 모서리 */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.06);
            min-height: 20px;
        }
        
        .placed-box:hover {
            z-index: 6;
            /* transform 제거 - 타임셀에 정확히 맞춤 유지 */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            background: #fafbfc;  /* 호버시 배경색 약간 변경 */
        }
        
        .placed-box.dragging {
            opacity: 0.05;
            z-index: 100;
        }
        
        .placed-box.resizing {
            cursor: ns-resize;
            opacity: 0.8;
        }
        
        .placed-box.food {
            background: linear-gradient(90deg, #FFF5E6 0%, #FFEFDD 100%);
            border: none;
            /* 왼쪽 색상 강조를 위한 box-shadow로 대체 */
            box-shadow: inset 4px 0 0 #FF9500, 0 2px 4px rgba(0, 0, 0, 0.06);
        }
        
        .placed-box.transport {
            background: linear-gradient(90deg, #E6FFF5 0%, #DFFFF0 100%);
            border: none;
            /* 왼쪽 색상 강조를 위한 box-shadow로 대체 */
            box-shadow: inset 4px 0 0 #00D084, 0 2px 4px rgba(0, 0, 0, 0.06);
        }
        
        .placed-box.activity {
            background: linear-gradient(90deg, #EBF3FF 0%, #E1EDFF 100%);
            border: none;
            /* 왼쪽 색상 강조를 위한 box-shadow로 대체 */
            box-shadow: inset 4px 0 0 #579AFF, 0 2px 4px rgba(0, 0, 0, 0.06);
        }
        
        .placed-box.sightseeing {
            background: linear-gradient(90deg, #F4EDFF 0%, #EDE4FF 100%);
            border: none;
            /* 왼쪽 색상 강조를 위한 box-shadow로 대체 */
            box-shadow: inset 4px 0 0 #A374F9, 0 2px 4px rgba(0, 0, 0, 0.06);
        }
        
        .placed-box.shopping {
            background: linear-gradient(90deg, #FFEBF2 0%, #FFDFEA 100%);
            border: none;
            /* 왼쪽 색상 강조를 위한 box-shadow로 대체 */
            box-shadow: inset 4px 0 0 #FF6B9D, 0 2px 4px rgba(0, 0, 0, 0.06);
        }
        
        .placed-box.accommodation {
            background: linear-gradient(90deg, #F0E9FF 0%, #E8DFFF 100%);
            border: none;
            /* 왼쪽 색상 강조를 위한 box-shadow로 대체 */
            box-shadow: inset 4px 0 0 #784AF4, 0 2px 4px rgba(0, 0, 0, 0.06);
        }

        /* 작은 박스 크기별 스타일 - 20분 박스 */
        .placed-box.tiny {
            padding: 2px 6px;
            position: relative;  /* floating controls를 위한 position */
        }
        
        .placed-box.tiny .placed-box-time-header,
        .placed-box.tiny .placed-box-info,
        .placed-box.tiny .placed-box-controls {
            display: none;
        }
        
        .placed-box.tiny .placed-box-header {
            margin: 0;
            display: flex;
            flex-direction: row;
            align-items: center;
            width: calc(100% - 20px);  /* floating controls 공간 확보 */
        }
        
        .placed-box.tiny .placed-box-time {
            font-size: 12px;  /* 10px → 12px */
            font-weight: 700;
            margin-right: 4px;
            white-space: nowrap;
        }
        
        .placed-box.tiny .placed-box-title {
            font-size: 10px;
            font-weight: 500;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        /* 30분 박스 - 한줄 표시 */
        .placed-box.compact {
            padding: 4px 8px;
        }

        .placed-box.compact .placed-box-content {
            display: flex;
            flex-direction: column;
            gap: 2px;
            overflow: hidden;  /* 컨테이너 오버플로우 방지 */
        }
        
        .placed-box.compact .placed-box-header {
            margin-bottom: 0;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .placed-box.compact .placed-box-time {
            font-size: 13px;  /* 11px → 13px */
            font-weight: 600;
        }
        
        .placed-box.compact .placed-box-title {
            font-size: 12px;
            line-height: 1.2;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 100%;  /* 너비 제한 */
        }
        
        .placed-box.compact .placed-box-time-header,
        .placed-box.compact .placed-box-info {
            display: none;
        }
        
        /* 40분 박스 - 시간과 제목이 한 줄에 표시 */
        .placed-box.medium {
            padding: 6px 8px;
        }
        
        .placed-box.medium .placed-box-header {
            display: flex;
            align-items: center;
            gap: 6px;
            height: 100%;
        }
        
        .placed-box.medium .placed-box-time {
            font-size: 14px;  /* 12px → 14px */
            font-weight: 600;
            flex-shrink: 0;
        }
        
        .placed-box.medium .placed-box-title {
            font-size: 13px;
            font-weight: 500;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .placed-box.medium .placed-box-info,
        .placed-box.medium .placed-box-memo {
            display: none;
        }
        
        /* 중복된 compact 스타일 제거 - 위의 정의 사용 */
        
        .placed-box-time-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2px;
        }
        
        .placed-box-time {
            font-size: 14px;  /* 11px → 14px - 일반 크기 박스 */
            color: #212529;
            font-weight: 600;
        }
        
        .placed-box-duration {
            font-size: 10px;
            color: #667eea;
            font-weight: 600;
        }
        
        .placed-box-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 2px;
            overflow: hidden;
        }
        
        .placed-box-title {
            font-size: 13px;
            font-weight: 700;
            color: #212529;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
            line-height: 1.3;
        }
        
        /* 외부 플로팅 컨트롤 */
        .placed-box-floating-controls {
            position: absolute;
            top: 4px;
            right: 4px;
            display: none;
            gap: 4px;
            z-index: 20;
        }

        .placed-box:hover .placed-box-floating-controls {
            display: flex;
        }
        
        /* 모든 크기의 박스에서 더보기 아이콘 표시 */
        .placed-box .placed-box-floating-controls .view {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 50%;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            border: none;
            pointer-events: all;  /* 클릭 이벤트 활성화 */
        }
        
        .placed-box .placed-box-floating-controls .view:hover {
            background: rgba(255, 255, 255, 1);
            transform: scale(1.1);
        }
        
        /* tiny 박스의 아이콘은 더 작게 */
        .placed-box.tiny .placed-box-floating-controls .view {
            width: 16px;
            height: 16px;
        }
        
        .placed-box.tiny .placed-box-floating-controls .view .material-icons {
            font-size: 12px !important;
        }

        /* tiny 박스 hover 시에만 아이콘 표시 */
        .placed-box.tiny .placed-box-floating-controls {
            display: none;  /* 기본적으로 숨김 */
            position: absolute;
            top: 1px;
            right: 2px;
            transform: none;
            z-index: 100;
        }
        
        .placed-box.tiny:hover .placed-box-floating-controls {
            display: flex;  /* hover 시에만 표시 */
        }
        
        /* compact, medium 박스도 hover 시에만 표시 */
        .placed-box.compact .placed-box-floating-controls,
        .placed-box.medium .placed-box-floating-controls {
            display: none;
            position: absolute;
            top: 2px;
            right: 2px;
            transform: none;
            z-index: 100;
        }
        
        .placed-box.compact:hover .placed-box-floating-controls,
        .placed-box.medium:hover .placed-box-floating-controls {
            display: flex;
        }
        
        
        .placed-box-control {
            width: 20px;
            height: 20px;
            background: #f8f9fa;
            border: none;
            color: #495057;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.2s;
            border-radius: 4px;
        }
        
        .placed-box-control:hover {
            color: #212529;
            background: #e9ecef;
        }
        
        .placed-box-control.delete {
            color: #999;
        }
        
        .placed-box-control.delete:hover {
            color: #fff;
            background: #f44336;
        }
        
        .placed-box-control.delete span {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .placed-box-info {
            font-size: 11px;
            color: #212529;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .placed-box-memo {
            font-size: 11px;
            color: #868e96;
            line-height: 1.4;
            margin-top: 2px;
            overflow: hidden;
            word-wrap: break-word;
            white-space: normal;
            flex: 1;
            min-height: 0;
            display: -webkit-box;
            -webkit-box-orient: vertical;
            text-overflow: ellipsis;
        }
        
        .placed-box-location {
            font-size: 11px;
            color: #2196F3;
            margin-top: 2px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        /* 리사이징 중일 때 스타일 */
        .placed-box.resizing {
            opacity: 0.8;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 200;
            cursor: ns-resize !important;
        }
        
        /* 모달 */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            backdrop-filter: blur(4px);
        }
        
        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.2s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .modal-content {
            background: #fff;
            border-radius: 12px;
            padding: 32px;
            width: 500px;
            max-width: 90%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: slideUp 0.3s ease;
        }
        
        @keyframes slideUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 2px solid #e9ecef;
        }
        
        .modal-title {
            font-size: 18px;
            color: #212529;
            font-weight: 700;
        }
        
        .modal-close {
            background: transparent;
            border: none;
            color: #adb5bd;
            font-size: 24px;
            cursor: pointer;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            transition: all 0.2s;
        }
        
        .modal-close:hover {
            color: #495057;
            background: #f8f9fa;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            font-size: 13px;
            color: #495057;
            margin-bottom: 8px;
            font-weight: 600;
        }
        
        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            color: #212529;
            padding: 10px 14px;
            font-size: 14px;
            border-radius: 8px;
            transition: all 0.2s;
            font-weight: 500;
        }
        
        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #667eea;
            background: #fff;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .form-group textarea {
            resize: vertical;
            min-height: 80px;
            font-family: inherit;
        }
        
        .time-inputs {
            display: grid;
            grid-template-columns: 90px 40px 90px 40px;
            gap: 12px;
            align-items: center;
        }
        
        .time-inputs input,
        .time-inputs select {
            width: 100%;
        }
        
        .time-inputs span {
            color: #868e96;
            font-size: 13px;
            font-weight: 500;
        }

        .end-time-display {
            padding: 10px;
            background: #f0f4ff;
            border-radius: 8px;
            color: #667eea;
            font-weight: 600;
            font-size: 14px;
            text-align: center;
            margin-top: 12px;
        }
        
        .modal-buttons {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            margin-top: 28px;
        }
        
        .btn {
            padding: 10px 24px;
            border: none;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 8px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }
        
        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: #f8f9fa;
            color: #495057;
            border: 2px solid #e9ecef;
        }
        
        .btn-secondary:hover {
            background: #e9ecef;
            border-color: #dee2e6;
        }
        
        .btn-danger {
            background: #dc3545;
            color: #fff;
            border: 2px solid #dc3545;
        }
        
        .btn-danger:hover {
            background: #c82333;
            border-color: #c82333;
            transform: translateY(-1px);
        }
        
        /* 스크롤바 스타일 */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        
        ::-webkit-scrollbar-track {
            background: #f8f9fa;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #dee2e6;
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #ced4da;
        }
        
        /* 확인 모달 */
        .confirm-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            backdrop-filter: blur(4px);
        }
        
        .confirm-modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.2s ease;
        }
        
        .confirm-content {
            background: #fff;
            border-radius: 12px;
            padding: 28px;
            width: 360px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: slideUp 0.3s ease;
        }
        
        .confirm-message {
            color: #212529;
            font-size: 15px;
            margin-bottom: 24px;
            font-weight: 500;
        }
        
        .confirm-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
        }
        
        .btn-confirm {
            background: #ff6b6b;
            color: #fff;
        }
        
        .btn-confirm:hover {
            background: #fa5252;
            transform: translateY(-1px);
        }
        
        /* 빈 공간 시간 표시 */
        .gap-indicator {
            position: absolute;
            left: 4px;
            right: 4px;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2;
        }
        
        .gap-line-top {
            width: 1px;
            background: repeating-linear-gradient(
                to bottom,
                #adb5bd 0,
                #adb5bd 4px,
                transparent 4px,
                transparent 8px
            );
            flex: 1;
        }
        
        .gap-line-bottom {
            width: 1px;
            background: repeating-linear-gradient(
                to bottom,
                #adb5bd 0,
                #adb5bd 4px,
                transparent 4px,
                transparent 8px
            );
            flex: 1;
        }
        
        .gap-time {
            background: rgba(255, 255, 255, 0.95);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            color: #6c757d;
            font-weight: 600;
            white-space: nowrap;
            border: 1px solid #dee2e6;
            margin: 2px 0;
        }
        
        /* 드래그 고스트 스타일 */
        .drag-ghost {
            position: absolute;
            pointer-events: none;
            opacity: 0.5;
            background: rgba(74, 144, 226, 0.3);
            border-top: 2px dashed #4a90e2;
            border-bottom: 2px dashed #4a90e2;
            border-left: 4px solid #4a90e2;
            border-right: none;
            /* border-radius 제거 - 각진 모서리 */
            transition: none;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #4a90e2;
            font-weight: bold;
            font-size: 12px;
        }
        
        .drag-ghost.food {
            background: rgba(255, 193, 7, 0.3);
            border-top: 2px dashed #ffc107;
            border-bottom: 2px dashed #ffc107;
            border-left: 4px solid #ffc107;
            color: #f39c12;
        }
        
        .drag-ghost.transport {
            background: rgba(40, 167, 69, 0.3);
            border-top: 2px dashed #28a745;
            border-bottom: 2px dashed #28a745;
            border-left: 4px solid #28a745;
            color: #27ae60;
        }
        
        .drag-ghost.activity {
            background: rgba(74, 144, 226, 0.3);
            border-top: 2px dashed #4a90e2;
            border-bottom: 2px dashed #4a90e2;
            border-left: 4px solid #4a90e2;
            color: #3498db;
        }
        
        .drag-ghost.accommodation {
            background: rgba(173, 80, 210, 0.3);
            border-top: 2px dashed #ad50d2;
            border-bottom: 2px dashed #ad50d2;
            border-left: 4px solid #ad50d2;
            color: #9b59b6;
        }
        
        .drag-ghost.shopping {
            background: rgba(255, 107, 157, 0.3);
            border-top: 2px dashed #FF6B9D;
            border-bottom: 2px dashed #FF6B9D;
            border-left: 4px solid #FF6B9D;
            color: #e91e63;
        }
        
        .drag-ghost.sightseeing {
            background: rgba(163, 116, 249, 0.3);
            border-top: 2px dashed #A374F9;
            border-bottom: 2px dashed #A374F9;
            border-left: 4px solid #A374F9;
            color: #9c27b0;
        }
        
        
        /* 인쇄 스타일 최적화 */
        @media print {
            @page {
                size: A4 landscape;
                margin: 10mm;
            }
            
            body {
                background: white;
                font-size: 11px;
            }
            
            .header {
                display: none !important;
            }
            
            .planbox-area {
                display: none !important;
            }
            
            .modal,
            .confirm-modal {
                display: none !important;
            }
            
            .placed-box-floating-controls,
            .resize-handle {
                display: none !important;
            }
            
            .main-layout {
                grid-template-columns: 1fr;
                height: auto;
                margin: 0;
            }
            
            .timeline-area {
                margin: 0;
                box-shadow: none;
                border-radius: 0;
                border: 1px solid #dee2e6;
            }
            
            .timeline-container {
                transform: scale(0.85);
                transform-origin: top left;
                width: 100%;
            }
            
            .time-labels {
                width: 50px;
                border-right: 1px solid #dee2e6;
            }
            
            .time-label {
                height: 40px;
                font-size: 10px;
                border-bottom: 1px solid #f1f3f5;
            }
            
            .day-column {
                width: 110px;
                border-right: 1px solid #dee2e6;
            }
            
            .day-header {
                height: 35px;
                font-size: 11px;
                border-bottom: 1px solid #dee2e6;
            }
            
            .time-slot {
                height: 40px;
                border-bottom: 1px solid #f1f3f5;
            }
            
            .time-slot::before,
            .time-slot::after {
                display: none;
            }
            
            .placed-box {
                border: 1px solid #868e96 !important;
                box-shadow: none !important;
                transform: none !important;
                page-break-inside: avoid;
            }
            
            .placed-box-title {
                font-size: 9px !important;
            }
            
            .placed-box-time,
            .placed-box-info {
                font-size: 8px !important;
            }
            
            .placed-box.food {
                border-left: 3px solid #ff6b6b !important;
            }
            
            .placed-box.transport {
                border-left: 3px solid #51cf66 !important;
            }
            
            .placed-box.activity {
                border-left: 3px solid #339af0 !important;
            }
            
            .placed-box.accommodation {
                border-left: 3px solid #845ef7 !important;
            }
            
            /* 압축 모드 빈 시간 숨김 */
            .time-slot.empty-print {
                display: none;
            }
            
            .time-label.empty-print {
                display: none;
            }
        }
        
        /* 카테고리 버튼 스타일 개선 */
        .quick-category-buttons {
            background: linear-gradient(to bottom, #fafbfc, #f6f7f9);
        }
        
        .quick-btn {
            transition: all 0.2s ease;
            font-weight: 500;
        }
        
        .quick-btn:hover {
            filter: saturate(1.3);
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }
        
        .quick-btn:active {
            transform: translateY(0);
            filter: saturate(1.1);
            box-shadow: 0 1px 3px rgba(0,0,0,0.15);
        }
        
        /* 모바일 반응형 디자인 */
        @media (max-width: 768px) {
            body {
                overflow-x: auto;
                overflow-y: hidden;
            }
            
            .header {
                position: sticky;
                top: 0;
                z-index: 1000;
                padding: 0 12px;
            }
            
            .header h1 {
                font-size: 16px;
            }
            
            .main-layout {
                flex-direction: row;
                height: calc(100vh - 56px);
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .planbox-area {
                width: 40vw;
                min-width: 300px;
                position: sticky;
                left: 0;
                background: white;
                z-index: 100;
                border-right: 2px solid #dee2e6;
                height: 100%;
                overflow-y: auto;
            }
            
            .timeline-area {
                width: 60vw;
                min-width: 400px;
                height: 100%;
                overflow-y: auto;
            }
            
            .day-columns {
                display: flex;
                gap: 0;
            }
            
            .day-column {
                min-width: 120px;
                flex-shrink: 0;
            }
            
            .time-slot {
                padding: 4px;
                font-size: 11px;
            }
            
            .placed-box {
                font-size: 11px;
                padding: 4px 6px;
            }
            
            .placed-box-title {
                font-size: 12px;
            }
            
            .quick-category-buttons {
                padding: 8px 6px;
                gap: 4px;
            }
            
            .quick-btn {
                padding: 6px 8px;
                font-size: 12px;
            }
            
            .add-planbox-btn {
                padding: 6px 10px;
                font-size: 13px;
            }
            
            .planbox-item {
                padding: 10px;
            }
            
            .planbox-title {
                font-size: 13px;
            }
            
            .planbox-time {
                font-size: 11px;
            }
            
            /* 모달 모바일 최적화 */
            .modal-content {
                width: 90%;
                max-width: 400px;
                padding: 16px;
            }
            
            .modal h2 {
                font-size: 18px;
            }
            
            /* 드래그 핸들 크기 증가 (터치 친화적) */
            .planbox-item {
                height: 60px;
                min-height: 60px;
                max-height: 60px;
                touch-action: none;
            }
            
            /* 스크롤바 스타일 */
            ::-webkit-scrollbar {
                height: 6px;
                width: 6px;
            }
            
            ::-webkit-scrollbar-track {
                background: #f1f1f1;
            }
            
            ::-webkit-scrollbar-thumb {
                background: #888;
                border-radius: 3px;
            }
        }
        
        /* 태블릿 대응 */
        @media (min-width: 769px) and (max-width: 1024px) {
            .main-layout {
                gap: 16px;
            }
            
            .planbox-area {
                width: 320px;
            }
            
            .day-column {
                width: 140px;
            }
        }

        /* 지도 모달 스타일 */
        .map-modal-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            width: 90%;
            max-width: 900px;
            max-height: 80vh;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            z-index: 10001;
        }

        .map-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .map-modal-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
        }

        .map-modal-header .close-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .map-modal-header .close-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .map-search-container {
            padding: 16px 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            gap: 10px;
        }

        #mapSearchInput {
            flex: 1;
            padding: 10px 16px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.2s;
        }

        #mapSearchInput:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .search-btn {
            background: var(--md-primary);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .search-btn:hover {
            background: #1565C0;
            transform: translateY(-1px);
        }

        /* 위치 자동완성 드롭다운 */
        .location-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 250px;
            overflow-y: auto;
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            margin-top: 4px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10000;
            display: none;
        }
        
        .location-dropdown.show {
            display: block;
        }
        
        .location-item {
            padding: 10px 12px;
            cursor: default;
            border-bottom: 1px solid #f1f3f5;
            transition: background 0.2s;
        }
        
        .location-item:last-child {
            border-bottom: none;
        }
        
        .location-item:hover {
            background: #f8f9fa;
        }
        
        .location-item.selected {
            background: #e3f2fd;
        }
        
        .location-item-name {
            font-weight: 600;
            color: #212529;
            font-size: 14px;
            margin-bottom: 2px;
        }
        
        .location-item-address {
            font-size: 12px;
            color: #868e96;
            line-height: 1.3;
        }
        
        .location-item-category {
            display: inline-block;
            font-size: 11px;
            color: #667eea;
            background: #f3f0ff;
            padding: 2px 6px;
            border-radius: 4px;
            margin-top: 4px;
        }
        
        #map {
            width: 100%;
            height: 500px;
        }

        .map-modal-footer {
            padding: 16px 20px;
            background: #f8f9fa;
            border-top: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #selectedAddress {
            flex: 1;
            color: #495057;
            font-size: 14px;
        }

        .confirm-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .confirm-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
    </style>
</head>
<body class="edit-mode">
    <div class="header">
        <div class="header-logo">
            <div class="logo-icon">T</div>
            <span style="color: red; font-weight: bold; margin-left: 10px;">v9.45 STABLE</span>
            <button onclick="testResize()" style="background: red; color: white; padding: 5px; margin-left: 10px;">리사이즈 테스트</button>
            <button onclick="clearAndRestart()" style="background: blue; color: white; padding: 5px; margin-left: 10px;">초기화 및 새로고침</button>
        </div>
        <div class="header-controls">
            <input type="text" id="tripTitle" placeholder="여행 제목" value="도쿄 여행">
            <input type="date" id="startDate" value="2025-01-15">
            <span style="color: #868e96;">~</span>
            <input type="date" id="endDate" value="2025-01-21">
            <button class="btn-header" onclick="updateTimeline()">적용</button>
            
            
            <button class="btn-print" onclick="printSchedule()">인쇄</button>
        </div>
    </div>
    
    <div class="main-layout">
        <div class="timeline-area">
            <div class="timeline-container">
                <div class="time-labels" id="timeLabels"></div>
                <div class="day-columns" id="dayColumns"></div>
            </div>
        </div>
        
        <div class="planbox-area">
            <!-- 플랜박스 생성 영역 -->
            <div class="creation-zone" style="background: linear-gradient(to bottom, #FAFBFC 0%, #F7F8FA 100%); padding: 10px 12px; border-bottom: 1px solid #E5E8EB;">
                <!-- 카테고리 빠른 생성 버튼 (Google Material Design Colors) -->
                <div class="quick-category-buttons" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; margin-bottom: 8px;">
                    <button class="quick-btn cat-transport" onclick="createTransportBox()" style="padding: 10px 8px; border: none; border-radius: 12px; background: #00D084; color: white; cursor: pointer; font-size: 13px; font-weight: 500; transition: all 0.15s ease; display: flex; align-items: center; justify-content: center; gap: 4px; box-shadow: 0 1px 3px rgba(0,208,132,0.3);">
                        <span class="material-icons-outlined" style="font-size: 18px;">directions</span>
                        이동
                    </button>
                    <button class="quick-btn cat-activity" onclick="createQuickBox('activity')" style="padding: 10px 8px; border: none; border-radius: 12px; background: #2196F3; color: white; cursor: pointer; font-size: 13px; font-weight: 500; transition: all 0.15s ease; display: flex; align-items: center; justify-content: center; gap: 4px; box-shadow: 0 1px 3px rgba(33,150,243,0.3);">
                        <span class="material-icons-outlined" style="font-size: 18px;">sports_soccer</span>
                        활동
                    </button>
                    <button class="quick-btn cat-sightseeing" onclick="createQuickBox('sightseeing')" style="padding: 10px 8px; border: none; border-radius: 12px; background: #9C27B0; color: white; cursor: pointer; font-size: 13px; font-weight: 500; transition: all 0.15s ease; display: flex; align-items: center; justify-content: center; gap: 4px; box-shadow: 0 1px 3px rgba(156,39,176,0.3);">
                        <span class="material-icons-outlined" style="font-size: 18px;">photo_camera</span>
                        관광
                    </button>
                    <button class="quick-btn cat-food" onclick="createQuickBox('food')" style="padding: 10px 8px; border: none; border-radius: 12px; background: #FF9800; color: white; cursor: pointer; font-size: 13px; font-weight: 500; transition: all 0.15s ease; display: flex; align-items: center; justify-content: center; gap: 4px; box-shadow: 0 1px 3px rgba(255,152,0,0.3);">
                        <span class="material-icons-outlined" style="font-size: 18px;">restaurant</span>
                        식사
                    </button>
                    <button class="quick-btn cat-shopping" onclick="createQuickBox('shopping')" style="padding: 10px 8px; border: none; border-radius: 12px; background: #E91E63; color: white; cursor: pointer; font-size: 13px; font-weight: 500; transition: all 0.15s ease; display: flex; align-items: center; justify-content: center; gap: 4px; box-shadow: 0 1px 3px rgba(233,30,99,0.3);">
                        <span class="material-icons-outlined" style="font-size: 18px;">shopping_bag</span>
                        쇼핑
                    </button>
                    <button class="quick-btn cat-accommodation" onclick="createQuickBox('accommodation')" style="padding: 10px 8px; border: none; border-radius: 12px; background: #673AB7; color: white; cursor: pointer; font-size: 13px; font-weight: 500; transition: all 0.15s ease; display: flex; align-items: center; justify-content: center; gap: 4px; box-shadow: 0 1px 3px rgba(103,58,183,0.3);">
                        <span class="material-icons-outlined" style="font-size: 18px;">hotel</span>
                        숙박
                    </button>
                </div>
                <!-- 맞춤 플랜박스 버튼 -->
                <button class="add-planbox-btn" onclick="showAddModal()" style="width: 100%; padding: 11px; background: #1976D2; color: white; border: none; border-radius: 12px; cursor: pointer; font-size: 14px; font-weight: 500; box-shadow: 0 1px 3px rgba(25,118,210,0.3); transition: all 0.15s ease; display: flex; align-items: center; justify-content: center; gap: 6px;">
                    <span class="material-icons" style="font-size: 20px;">add_circle_outline</span>
                    맞춤 플랜박스
                </button>
            </div>
            
            <!-- 필터링 영역 -->
            <div class="filter-zone" style="padding: 8px 12px; background: #FAFBFC; border-bottom: 1px solid #E5E8EB;">
                <div style="display: flex; align-items: center; gap: 6px;">
                    <span style="font-size: 13px; color: #495057; font-weight: 500;">필터</span>
                    <select id="categoryFilter" onchange="filterByCategory(this.value)" style="flex: 1; padding: 5px 8px; border: 1px solid #dee2e6; border-radius: 4px; background: white; font-size: 13px; cursor: pointer;">
                        <option value="all">전체</option>
                        <option value="custom">맞춤</option>
                        <option value="transport">이동</option>
                        <option value="activity">활동</option>
                        <option value="sightseeing">관광</option>
                        <option value="food">식사</option>
                        <option value="shopping">쇼핑</option>
                        <option value="accommodation">숙박</option>
                    </select>
                </div>
            </div>
            <div class="planbox-list" id="planboxList"></div>
        </div>
    </div>
    
    <!-- 플랜박스 상세 모달 (컴팩트 디자인) -->
    <div class="modal" id="planboxModal">
        <div class="modal-content" style="max-width: 550px; display: flex; flex-direction: column; padding: 0;">
            <!-- 모달 헤더 (제목 인라인 편집) -->
            <div style="padding: 18px 24px; border-bottom: 1px solid #e0e0e0; background: linear-gradient(to bottom, #fff, #fafafa);">
                <div style="display: flex; align-items: center; justify-content: space-between;">
                    <div style="display: flex; align-items: center; gap: 10px; flex: 1;">
                        <h2 id="modalTitleDisplay" onclick="startTitleEdit()" style="font-size: 22px; font-weight: 600; color: #212529; cursor: text; padding: 2px 6px; border-radius: 4px; transition: all 0.2s;">새 플랜</h2>
                        <input type="text" id="modalTitleEdit" style="display: none; font-size: 22px; font-weight: 600; border: none; border-bottom: 2px solid #1976D2; outline: none; flex: 1; background: transparent;" onblur="finishTitleEdit()" onkeydown="handleTitleEditKey(event)">
                        <button onclick="startTitleEdit()" style="background: none; border: none; cursor: pointer; padding: 4px; display: flex; align-items: center; justify-content: center; border-radius: 50%; transition: all 0.2s;">
                            <span class="material-icons-outlined" style="font-size: 18px; color: #999;">edit</span>
                        </button>
                    </div>
                    <button class="modal-close" onclick="hideModal()" style="background: none; border: none; font-size: 28px; cursor: pointer; color: #999; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border-radius: 50%; transition: all 0.2s;">×</button>
                </div>
            </div>
            
            <!-- 모달 바디 -->
            <div style="padding: 20px 24px; background: #fafafa;">
                <!-- 시간 정보 (2열 레이아웃) -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 18px;">
                    <div>
                        <label style="font-size: 12px; color: #666; display: block; margin-bottom: 4px; font-weight: 500;">
                            <span class="material-icons-outlined" style="font-size: 14px; vertical-align: middle;">schedule</span>
                            시작 시간
                        </label>
                        <div style="display: flex; gap: 4px;">
                            <select id="startHour" style="flex: 1; padding: 7px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px;"></select>
                            <select id="startMinute" style="width: 60px; padding: 7px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px;"></select>
                        </div>
                    </div>
                    <div>
                        <label style="font-size: 12px; color: #666; display: block; margin-bottom: 4px; font-weight: 500;">
                            <span class="material-icons-outlined" style="font-size: 14px; vertical-align: middle;">timer</span>
                            소요 시간
                        </label>
                        <div style="display: flex; gap: 4px; align-items: center;">
                            <input type="number" id="durationHour" min="0" max="23" value="0" style="width: 45px; padding: 7px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px;">
                            <span style="color: #999; font-size: 12px;">시간</span>
                            <select id="durationMinute" style="width: 60px; padding: 7px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px;">
                                <option value="0">0</option>
                                <option value="10">10</option>
                                <option value="20">20</option>
                                <option value="30" selected>30</option>
                                <option value="40">40</option>
                                <option value="50">50</option>
                            </select>
                            <span style="color: #999; font-size: 12px;">분</span>
                        </div>
                    </div>
                </div>
                <div id="endTimeDisplay" style="margin-bottom: 18px; padding: 8px; background: #e3f2fd; border-radius: 6px; text-align: center; color: #1976D2; font-size: 13px; font-weight: 500;">종료: --:--</div>
                
                <!-- 카테고리와 비용 (2열) -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 18px;">
                    <div>
                        <label style="font-size: 12px; color: #666; display: block; margin-bottom: 4px; font-weight: 500;">
                            <span class="material-icons-outlined" style="font-size: 14px; vertical-align: middle;">category</span>
                            카테고리
                        </label>
                        <select id="boxCategory" style="width: 100%; padding: 7px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px;">
                            <option value="food">🍽️ 식사</option>
                            <option value="activity">⚽ 활동</option>
                            <option value="sightseeing">📷 관광</option>
                            <option value="shopping">🛍️ 쇼핑</option>
                            <option value="accommodation">🏨 숙박</option>
                        </select>
                    </div>
                    <div>
                        <label style="font-size: 12px; color: #666; display: block; margin-bottom: 4px; font-weight: 500;">
                            <span class="material-icons-outlined" style="font-size: 14px; vertical-align: middle;">payments</span>
                            예상 비용
                        </label>
                        <input type="text" id="boxCost" placeholder="예: 3,000원" style="width: 100%; padding: 7px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px;">
                    </div>
                </div>
                
                <!-- 위치 정보 (임시 버튼) -->
                <div style="margin-bottom: 18px;">
                    <label style="font-size: 12px; color: #666; display: block; margin-bottom: 4px; font-weight: 500;">
                        <span class="material-icons-outlined" style="font-size: 14px; vertical-align: middle;">location_on</span>
                        위치 정보
                    </label>
                    <div style="position: relative;">
                        <input type="text" id="locationInput" placeholder="장소명 또는 주소 입력" style="width: 100%; padding: 7px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px;" autocomplete="off">
                        <div id="locationDropdown" class="location-dropdown"></div>
                    </div>
                </div>
                
                <!-- 이동박스 전용 경로 정보 (숨김) -->
                <div id="transportRouteInfo" style="display: none; margin-bottom: 18px; background: #f0f8ff; border: 1px solid #2196F3; border-radius: 8px; padding: 12px;">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
                        <div style="flex: 1;">
                            <div style="font-size: 11px; color: #666;">출발지</div>
                            <div id="routeFromLocation" style="font-size: 14px; font-weight: 600; color: #2196F3;">자동 감지</div>
                        </div>
                        <span class="material-icons" style="color: #2196F3;">arrow_forward</span>
                        <div style="flex: 1;">
                            <div style="font-size: 11px; color: #666;">도착지</div>
                            <div id="routeToLocation" style="font-size: 14px; font-weight: 600; color: #2196F3;">자동 감지</div>
                        </div>
                        <button onclick="showRouteDetails()" style="background: #4CAF50; color: white; border: none; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 16px;">
                            <span class="material-icons" style="font-size: 18px;">map</span>
                        </button>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; font-size: 12px; color: #666;">
                        <div>거리: <span id="routeDistanceText" style="font-weight: 600; color: #2196F3;">계산중...</span></div>
                        <div>소요시간: <span id="routeDurationText" style="font-weight: 600; color: #2196F3;">계산중...</span></div>
                    </div>
                </div>

                <!-- 메모 입력 -->
                <div>
                    <label style="font-size: 12px; color: #666; display: block; margin-bottom: 4px; font-weight: 500;">
                        <span class="material-icons-outlined" style="font-size: 14px; vertical-align: middle;">notes</span>
                        메모
                    </label>
                    <textarea id="boxMemo" placeholder="추가 정보나 팁을 입력하세요" style="width: 100%; padding: 7px; border: 1px solid #ddd; border-radius: 6px; min-height: 70px; resize: vertical; font-size: 14px; line-height: 1.4;"></textarea>
                </div>
                
                <!-- 숨겨진 제목 입력 (실제 저장용) -->
                <input type="hidden" id="boxTitle">
            </div>
            
            <!-- 모달 푸터 -->
            <div style="padding: 14px 24px; border-top: 1px solid #e0e0e0; display: flex; justify-content: space-between; align-items: center; background: white;">
                <button class="btn btn-danger" id="deleteBtn" onclick="deletePlanboxFromModal()" style="display: none; padding: 7px 14px; background: #f44336; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; display: flex; align-items: center; gap: 4px;">
                    <span class="material-icons" style="font-size: 16px;">delete_outline</span>
                    삭제
                </button>
                <div style="flex: 1;"></div>
                <button class="btn btn-secondary" onclick="hideModal()" style="padding: 7px 14px; background: white; color: #666; border: 1px solid #ddd; border-radius: 6px; cursor: pointer; margin-right: 8px; font-size: 13px; font-weight: 500;">취소</button>
                <button class="btn btn-primary" onclick="savePlanbox()" style="padding: 7px 18px; background: #1976D2; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; display: flex; align-items: center; gap: 4px;">
                    <span class="material-icons" style="font-size: 16px;">check</span>
                    저장
                </button>
            </div>
        </div>
    </div>
    
    <!-- 이동박스 전용 모달 -->
    <div class="modal" id="transportModal">
        <div class="modal-content" style="max-width: 600px; display: flex; flex-direction: column; padding: 0;">
            <!-- 모달 헤더 -->
            <div style="padding: 18px 24px; border-bottom: 1px solid #e0e0e0; background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%); color: white;">
                <div style="display: flex; align-items: center; justify-content: space-between;">
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <span class="material-icons" style="font-size: 24px;">directions</span>
                        <h2 style="margin: 0; font-size: 20px; font-weight: 600;">이동 계획</h2>
                    </div>
                    <button class="modal-close" onclick="hideTransportModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border-radius: 50%; cursor: pointer;">×</button>
                </div>
            </div>
            
            <!-- 경로 정보 -->
            <div id="routeInfo" style="padding: 20px 24px; background: #f8f9fa; border-bottom: 1px solid #e0e0e0;">
                <div style="display: flex; align-items: center; gap: 16px; margin-bottom: 16px;">
                    <div style="flex: 1;">
                        <div style="font-size: 12px; color: #666; margin-bottom: 4px;">출발지</div>
                        <div id="fromLocation" style="font-size: 16px; font-weight: 600; color: #2196F3;">-</div>
                    </div>
                    <div style="display: flex; align-items: center; justify-content: center; width: 40px; height: 40px; background: white; border-radius: 50%; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <span class="material-icons" style="font-size: 20px; color: #2196F3;">arrow_forward</span>
                    </div>
                    <div style="flex: 1;">
                        <div style="font-size: 12px; color: #666; margin-bottom: 4px;">도착지</div>
                        <div id="toLocation" style="font-size: 16px; font-weight: 600; color: #2196F3;">-</div>
                    </div>
                </div>
                
                <!-- 경로 결과 (자동 계산) -->
                <div id="routeResults" style="display: none; background: white; border-radius: 8px; padding: 16px; margin-bottom: 16px;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 16px; text-align: center;">
                        <div>
                            <div style="font-size: 12px; color: #666;">거리</div>
                            <div id="routeDistance" style="font-size: 18px; font-weight: 600; color: #2196F3;">-</div>
                        </div>
                        <div>
                            <div style="font-size: 12px; color: #666;">소요시간</div>
                            <div id="routeDuration" style="font-size: 18px; font-weight: 600; color: #2196F3;">-</div>
                        </div>
                        <div>
                            <div style="font-size: 12px; color: #666;">예상비용</div>
                            <div id="routeCost" style="font-size: 18px; font-weight: 600; color: #2196F3;">-</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 교통수단 선택 -->
            <div style="padding: 20px 24px; background: white;">
                <div style="margin-bottom: 16px;">
                    <label style="font-size: 14px; color: #333; font-weight: 600; margin-bottom: 8px; display: block;">교통수단</label>
                    <div id="transportMethods" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px;">
                        <button class="transport-method active" data-method="TRANSIT" onclick="selectTransportMethod('TRANSIT')" style="padding: 12px; border: 2px solid #2196F3; background: #e3f2fd; border-radius: 8px; cursor: pointer; text-align: center; transition: all 0.2s;">
                            <span class="material-icons" style="font-size: 24px; color: #2196F3; margin-bottom: 4px; display: block;">directions_transit</span>
                            <div style="font-size: 12px; color: #2196F3; font-weight: 600;">대중교통</div>
                        </button>
                        <button class="transport-method" data-method="DRIVING" onclick="selectTransportMethod('DRIVING')" style="padding: 12px; border: 2px solid #e0e0e0; background: white; border-radius: 8px; cursor: pointer; text-align: center; transition: all 0.2s;">
                            <span class="material-icons" style="font-size: 24px; color: #666; margin-bottom: 4px; display: block;">directions_car</span>
                            <div style="font-size: 12px; color: #666; font-weight: 600;">자동차</div>
                        </button>
                        <button class="transport-method" data-method="WALKING" onclick="selectTransportMethod('WALKING')" style="padding: 12px; border: 2px solid #e0e0e0; background: white; border-radius: 8px; cursor: pointer; text-align: center; transition: all 0.2s;">
                            <span class="material-icons" style="font-size: 24px; color: #666; margin-bottom: 4px; display: block;">directions_walk</span>
                            <div style="font-size: 12px; color: #666; font-weight: 600;">도보</div>
                        </button>
                        <button class="transport-method" data-method="BICYCLING" onclick="selectTransportMethod('BICYCLING')" style="padding: 12px; border: 2px solid #e0e0e0; background: white; border-radius: 8px; cursor: pointer; text-align: center; transition: all 0.2s;">
                            <span class="material-icons" style="font-size: 24px; color: #666; margin-bottom: 4px; display: block;">directions_bike</span>
                            <div style="font-size: 12px; color: #666; font-weight: 600;">자전거</div>
                        </button>
                    </div>
                </div>
                
                <!-- 시간 설정 (일반 모달과 동일) -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 16px;">
                    <div>
                        <label style="font-size: 12px; color: #666; display: block; margin-bottom: 4px; font-weight: 500;">
                            <span class="material-icons-outlined" style="font-size: 14px; vertical-align: middle;">schedule</span>
                            시작 시간
                        </label>
                        <div style="display: flex; gap: 4px;">
                            <select id="transportStartHour" style="flex: 1; padding: 7px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px;"></select>
                            <select id="transportStartMinute" style="width: 60px; padding: 7px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px;"></select>
                        </div>
                    </div>
                    <div>
                        <label style="font-size: 12px; color: #666; display: block; margin-bottom: 4px; font-weight: 500;">
                            <span class="material-icons-outlined" style="font-size: 14px; vertical-align: middle;">payments</span>
                            예상 비용
                        </label>
                        <input type="text" id="transportCost" placeholder="예: 2,500원" style="width: 100%; padding: 7px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px;">
                    </div>
                </div>
                
                <!-- 메모/상세정보 -->
                <div style="margin-bottom: 16px;">
                    <label style="font-size: 12px; color: #666; display: block; margin-bottom: 4px; font-weight: 500;">
                        <span class="material-icons-outlined" style="font-size: 14px; vertical-align: middle;">notes</span>
                        상세 정보
                    </label>
                    <textarea id="transportMemo" placeholder="이동 수단 상세 정보 (지하철 노선, 버스 번호 등)" style="width: 100%; padding: 7px; border: 1px solid #ddd; border-radius: 6px; min-height: 60px; resize: vertical; font-size: 14px;"></textarea>
                </div>
                
                <!-- 지도 보기 버튼 -->
                <button id="showRouteMap" onclick="showRouteOnMap()" style="width: 100%; padding: 12px; background: #4CAF50; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; margin-bottom: 16px; display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <span class="material-icons">map</span>
                    경로 지도 보기
                </button>
            </div>
            
            <!-- 모달 푸터 -->
            <div style="padding: 14px 24px; border-top: 1px solid #e0e0e0; display: flex; justify-content: space-between; align-items: center; background: #f8f9fa;">
                <button class="btn btn-danger" id="deleteTransportBtn" onclick="deleteTransportFromModal()" style="display: none; padding: 7px 14px; background: #f44336; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; display: flex; align-items: center; gap: 4px;">
                    <span class="material-icons" style="font-size: 16px;">delete_outline</span>
                    삭제
                </button>
                <div style="flex: 1;"></div>
                <button onclick="hideTransportModal()" style="padding: 7px 14px; background: white; color: #666; border: 1px solid #ddd; border-radius: 6px; cursor: pointer; margin-right: 8px; font-size: 13px; font-weight: 500;">취소</button>
                <button onclick="saveTransportBox()" style="padding: 7px 18px; background: #2196F3; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; display: flex; align-items: center; gap: 4px;">
                    <span class="material-icons" style="font-size: 16px;">check</span>
                    저장
                </button>
            </div>
        </div>
    </div>
    
    <div class="confirm-modal" id="confirmModal">
        <div class="confirm-content">
            <div class="confirm-message" id="confirmMessage">정말 삭제하시겠습니까?</div>
            <div class="confirm-buttons">
                <button class="btn btn-secondary" onclick="hideConfirm()">취소</button>
                <button class="btn btn-confirm" id="confirmBtn">삭제</button>
            </div>
        </div>
    </div>
    
    <script>
// 전역 변수
let planboxData = [], placedBoxes = {}, draggedElement = null, draggedData = null;
let editingBoxId = null, editingPlacedBox = null, totalDays = 7;
let timeRangeStart = 6, timeRangeEnd = 24, extendedStart = null, extendedEnd = null;
let occupiedSlots = {}, isCloneMode = false, cloneSourceId = null;
let isFirstDrop = true; // 리사이즈 관련 전역 변수는 setupResizeEvents 내부에서 관리
let tempPlacedBoxes = {};
let originalTimeDisplay = null;
let currentCategoryFilter = 'all';  // 카테고리 필터 상태
let tripRegion = 'domestic';  // 여행 지역 (domestic/overseas)
let isEditingTitle = false;  // 제목 편집 상태
let lastDragOverSlot = null;  // 마지막 드래그 오버 슬롯 추적

// TODO: 환율 및 비용 관련 기능 (추후 구현)
// - tripCurrency: 'KRW' // 여행 국가 통화 (USD, EUR, JPY, CNY 등)
// - exchangeRate: 1 // 현재 환율
// - showExchangeRate: true // 환율 변환 표시 여부
// - dailyCostSummary: {} // 각 날짜별 비용 합계

// 시간 블록 정의
const timeBlocks = {
    dawn: { start: 0, end: 6, label: '새벽', color: '#f3f0ff', textColor: '#6c5ce7' },
    morning: { start: 6, end: 12, label: '오전', color: '#fff3e0', textColor: '#f57c00' },
    afternoon: { start: 12, end: 18, label: '오후', color: '#e8f5e9', textColor: '#2e7d32' },
    evening: { start: 18, end: 24, label: '저녁', color: '#fce4ec', textColor: '#c2185b' }
};

// 뷰 모드 설정
function setViewMode(mode) {
    currentViewMode = mode;
    document.body.className = mode + '-mode';
    
    // 버튼 활성화 상태 변경
    document.querySelectorAll('.view-mode-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.mode === mode);
    });
    
    if (mode === 'compress' || mode === 'print') {
        updateCompressView();
    } else {
        createTimeLabels();
        createDayColumns();
    }
}

// 압축 뷰 업데이트
function updateCompressView() {
    // 빈 시간대 찾기
    const emptyHours = new Set();
    for (let hour = timeRangeStart; hour < timeRangeEnd; hour++) {
        let isEmpty = true;
        for (let day = 0; day < totalDays; day++) {
            if (hasEventsInHour(day, hour)) {
                isEmpty = false;
                break;
            }
        }
        if (isEmpty) {
            emptyHours.add(hour);
        }
    }
    
    // 시간 라벨과 슬롯에 empty 클래스 추가
    document.querySelectorAll('.time-label').forEach((label, index) => {
        const hour = timeRangeStart + index;
        if (emptyHours.has(hour)) {
            label.classList.add('empty');
            if (currentViewMode === 'print') {
                label.classList.add('empty-print');
            }
        } else {
            label.classList.remove('empty', 'empty-print');
        }
    });
    
    document.querySelectorAll('.time-slot').forEach(slot => {
        const hour = parseInt(slot.dataset.hour);
        if (emptyHours.has(hour)) {
            slot.classList.add('empty');
            if (currentViewMode === 'print') {
                slot.classList.add('empty-print');
            }
        } else {
            slot.classList.remove('empty', 'empty-print');
        }
    });
}

// 특정 시간에 이벤트가 있는지 확인
function hasEventsInHour(day, hour) {
    if (!placedBoxes[day]) return false;
    
    return placedBoxes[day].some(box => {
        const boxHour = parseInt(box.dataset.hour);
        const boxMinute = parseInt(box.dataset.minute);
        const boxDuration = parseInt(box.dataset.duration);
        const boxEndMinutes = boxHour * 60 + boxMinute + boxDuration;
        const boxEndHour = Math.floor(boxEndMinutes / 60);
        
        return boxHour <= hour && hour < boxEndHour;
    });
}

// 시간 블록 가져오기
function getTimeBlock(hour) {
    for (const [key, block] of Object.entries(timeBlocks)) {
        if (hour >= block.start && hour < block.end) {
            return { key, ...block };
        }
    }
    return null;
}

// 자동 저장 기능
let autoSaveInterval = null;
let lastSaveTime = null;
let hasUnsavedChanges = false;

function enableAutoSave() {
    // 5초마다 자동 저장
    autoSaveInterval = setInterval(() => {
        if (hasUnsavedChanges) {
            saveToLocalStorage();
        }
    }, 5000);
    
    console.log('자동 저장 기능 활성화 (5초 간격)');
}

function saveToLocalStorage() {
    // 버전 정보 저장
    localStorage.setItem('timeplanbox_version', 'v2.0');
    
    // placedBoxes를 저장 가능한 형태로 변환
    const placedBoxesData = {};
    Object.keys(placedBoxes).forEach(day => {
        placedBoxesData[day] = placedBoxes[day].map(box => ({
            id: box.dataset.dataId,
            hour: parseInt(box.dataset.hour),
            minute: parseInt(box.dataset.minute),
            duration: parseInt(box.dataset.duration),
            day: parseInt(box.dataset.day),
            title: box.dataset.title || '',
            category: box.className.split(' ').find(c => ['food', 'transport', 'activity', 'sightseeing', 'shopping', 'accommodation'].includes(c)) || 'activity',
            cost: box.dataset.cost || '',
            memo: box.dataset.memo || '',
            location: box.dataset.location || '',
            locationData: box.dataset.locationData ? JSON.parse(box.dataset.locationData) : null,
            isClone: box.dataset.isClone === 'true'
        }));
    });
    
    const saveData = {
        planboxData: planboxData,
        placedBoxesData: placedBoxesData,  // DOM 요소가 아닌 데이터만 저장
        totalDays: totalDays,
        timeRangeStart: timeRangeStart,
        timeRangeEnd: timeRangeEnd,
        lastSaved: new Date().toISOString(),
        version: '1.1' // 버전 관리
    };
    
    try {
        localStorage.setItem('timeplanbox_autosave', JSON.stringify(saveData));
        lastSaveTime = new Date();
        hasUnsavedChanges = false;
        updateSaveStatus('저장됨');
        console.log('자동 저장 완료:', lastSaveTime.toLocaleTimeString());
    } catch (e) {
        console.error('자동 저장 실패:', e);
        updateSaveStatus('저장 실패');
    }
}

function loadFromLocalStorage() {
    try {
        // 버전 체크 - 오래된 데이터는 무시
        const savedVersion = localStorage.getItem('timeplanbox_version');
        if (savedVersion !== 'v2.0') {
            console.log('오래된 버전 데이터 감지 - 초기화');
            localStorage.clear(); // 모든 오래된 데이터 삭제
            localStorage.setItem('timeplanbox_version', 'v2.0');
            localStorage.setItem('tripSetupComplete', 'true'); // 초기 설정은 유지
            return false;
        }
        
        const savedData = localStorage.getItem('timeplanbox_autosave');
        if (savedData) {
            const data = JSON.parse(savedData);
            
            // 버전 체크
            if (data.version === '1.1') {
                // null 값이 있는 데이터 정리
                planboxData = (data.planboxData || []).map(box => ({
                    ...box,
                    startHour: box.startHour === null ? null : (box.startHour || 0),
                    startMinute: box.startMinute === null ? null : (box.startMinute || 0)
                }));
                
                // placedBoxesData를 임시 저장 (나중에 DOM 재생성)
                if (data.placedBoxesData) {
                    tempPlacedBoxes = data.placedBoxesData;
                } else if (data.placedBoxes) {
                    // 구버전 호환성
                    tempPlacedBoxes = data.placedBoxes;
                }
                
                placedBoxes = {};
                totalDays = data.totalDays || 7;
                timeRangeStart = data.timeRangeStart || 6;
                timeRangeEnd = data.timeRangeEnd || 24;
                
                console.log('저장된 데이터 불러오기 완료:', data.lastSaved);
                updateSaveStatus('복원됨');
                return true;
            }
        }
    } catch (e) {
        console.error('데이터 불러오기 실패:', e);
    }
    return false;
}

function updateSaveStatus(status) {
    // 저장 상태를 헤더에 표시
    const header = document.querySelector('.header');
    let statusElement = document.getElementById('save-status');
    
    if (!statusElement) {
        statusElement = document.createElement('div');
        statusElement.id = 'save-status';
        statusElement.style.cssText = `
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 12px;
            color: #6c757d;
            padding: 4px 8px;
            background: rgba(255,255,255,0.9);
            border-radius: 4px;
        `;
        header.appendChild(statusElement);
    }
    
    statusElement.textContent = status;
    if (status === '저장됨') {
        statusElement.style.color = '#28a745';
    } else if (status === '저장 실패') {
        statusElement.style.color = '#dc3545';
    } else {
        statusElement.style.color = '#17a2b8';
    }
    
    // 3초 후 페이드아웃
    setTimeout(() => {
        statusElement.style.opacity = '0.5';
    }, 3000);
}

// 변경 감지 함수
function markAsChanged() {
    hasUnsavedChanges = true;
}

// 초기화
function init() {
    console.log('===== init 함수 시작 =====');
    console.log('Initializing app...');
    
    // 첫 방문시 초기 설정 모달 표시
    if (!localStorage.getItem('tripSetupComplete')) {
        showSetupModal();
        return;
    }
    
    let hasLoadedData = false; // 함수 스코프에서 사용할 수 있도록 let으로 선언
    
    try {
        // 저장된 지역 설정 불러오기
        tripRegion = localStorage.getItem('tripRegion') || 'domestic';
        
        // 저장된 데이터 불러오기 시도
        hasLoadedData = loadFromLocalStorage(); // const 제거
        console.log('Data loaded from localStorage:', hasLoadedData);
        
        console.log('Creating time labels...');
        createTimeLabels();
        console.log('Time labels created');
        
        console.log('Creating day columns...');
        createDayColumns();
        console.log('Day columns created');
    } catch (error) {
        console.error('Error during initialization:', error);
        console.error('Stack trace:', error.stack);
    }
    
    // 샘플 데이터 사용하지 않음 - 빈 상태로 시작
    if (!hasLoadedData) {
        console.log('새로운 시작 - 빈 타임라인');
        planboxData = [];
        placedBoxes = {};
        for (let i = 0; i < 7; i++) {
            placedBoxes[i] = [];
        }
    } else {
        // 저장된 데이터가 있으면 렌더링
        renderPlanboxList();
        restorePlacedBoxes();
    }
    
    setupEventListeners();
    
    // 자동 저장 기능 활성화
    enableAutoSave();
    initializeTimeSelects();
    
    // 위치 자동완성 초기화
    initLocationAutocomplete();
    
    // Kakao API 미리 로드 (로컬 서버에서 실행 중일 때만)
    if (window.location.protocol !== 'file:') {
        setTimeout(() => {
            if (typeof kakao === 'undefined' && !kakaoMapLoading) {
                console.log('초기화 시 Kakao API 미리 로드 시작');
                loadKakaoMapAPI(() => {
                    console.log('Kakao API 미리 로드 완료');
                });
            }
        }, 500);  // 약간의 지연 후 로드
    }
    
    // 초기 로드 시 모든 날짜의 간격 표시 업데이트
    setTimeout(() => {
        for (let day = 0; day < 7; day++) {
            updateGapIndicators(day);
        }
    }, 100);
}

// 시간 선택 초기화
function initializeTimeSelects() {
    const startHour = document.getElementById('startHour');
    const startMinute = document.getElementById('startMinute');
    
    startHour.innerHTML = '';
    for (let h = 0; h < 24; h++) {
        const option = document.createElement('option');
        option.value = h;
        option.textContent = h.toString().padStart(2, '0');
        startHour.appendChild(option);
    }
    
    startMinute.innerHTML = '';
    for (let m = 0; m < 60; m += 5) {  // 5분 단위로 변경
        const option = document.createElement('option');
        option.value = m;
        option.textContent = m.toString().padStart(2, '0');
        startMinute.appendChild(option);
    }
    
    // 기본값 설정 - 오전 9시
    startHour.value = 9;  
    startMinute.value = 0;

    startHour.addEventListener('change', updateEndTimeDisplay);
    startMinute.addEventListener('change', updateEndTimeDisplay);
    document.getElementById('durationHour').addEventListener('input', updateEndTimeDisplay);
    document.getElementById('durationMinute').addEventListener('change', updateEndTimeDisplay);
}

// 종료 시간 표시
function updateEndTimeDisplay() {
    const startHourValue = document.getElementById('startHour').value;
    const startHour = startHourValue === '' ? 9 : parseInt(startHourValue); // 빈 값이면 기본값 9시
    const startMinute = parseInt(document.getElementById('startMinute').value) || 0;
    const durationHour = parseInt(document.getElementById('durationHour').value) || 0;
    const durationMinute = parseInt(document.getElementById('durationMinute').value) || 0;

    const totalMinutes = startHour * 60 + startMinute + durationHour * 60 + durationMinute;
    const endHour = Math.floor(totalMinutes / 60) % 24;
    const endMinute = totalMinutes % 60;

    document.getElementById('endTimeDisplay').textContent = 
        `종료: ${endHour.toString().padStart(2, '0')}:${endMinute.toString().padStart(2, '0')}`;
}

// 시간 라벨 생성
function createTimeLabels() {
    const container = document.getElementById('timeLabels');
    if (!container) {
        console.error('timeLabels container not found!');
        return;
    }
    container.innerHTML = '';
    checkExtendedTimeRange();
    
    const createLabel = (hour) => {
        const label = document.createElement('div');
        label.className = 'time-label hour';
        label.textContent = `${hour.toString().padStart(2, '0')}:00`;
        
        const block = getTimeBlock(hour);
        if (block) {
            label.classList.add(`${block.key}-block`);
        }
        
        return label;
    };
    
    if (extendedStart !== null && extendedStart < timeRangeStart) {
        for (let hour = extendedStart; hour < timeRangeStart; hour++) {
            container.appendChild(createLabel(hour));
        }
    }
    
    for (let hour = timeRangeStart; hour < timeRangeEnd; hour++) {
        container.appendChild(createLabel(hour));
    }
    
    if (extendedEnd !== null && extendedEnd > timeRangeEnd) {
        for (let hour = timeRangeEnd; hour < extendedEnd; hour++) {
            container.appendChild(createLabel(hour));
        }
    }
}

// 확장 시간대 체크
function checkExtendedTimeRange() {
    extendedStart = null;
    extendedEnd = null;
    
    planboxData.forEach(box => {
        if (box.startHour < timeRangeStart) {
            if (extendedStart === null || box.startHour < extendedStart) {
                extendedStart = box.startHour;
            }
        }
        const endTime = box.startHour + Math.ceil((box.startMinute + box.durationHour * 60 + box.durationMinute) / 60);
        if (endTime > timeRangeEnd) {
            if (extendedEnd === null || endTime > extendedEnd) {
                extendedEnd = Math.min(endTime, 24);
            }
        }
    });

    Object.keys(placedBoxes).forEach(day => {
        placedBoxes[day].forEach(box => {
            // box가 유효한지 확인
            if (box && box.dataset) {
                const hour = parseInt(box.dataset.hour) || 0;
                const minute = parseInt(box.dataset.minute) || 0;
                const duration = parseInt(box.dataset.duration) || 60;
                
                if (hour < timeRangeStart) {
                    if (extendedStart === null || hour < extendedStart) {
                        extendedStart = hour;
                    }
                }
                
                const endTime = hour + Math.ceil((minute + duration) / 60);
                if (endTime > timeRangeEnd) {
                    if (extendedEnd === null || endTime > extendedEnd) {
                        extendedEnd = Math.min(endTime, 24);
                    }
                }
            }
        });
    });
}

// 날짜별 비용 합계 계산
function calculateDailyCost(day) {
    // TODO: 각 날짜의 모든 플랜박스 비용 합산
    // const dayBoxes = Object.values(placedBoxes).filter(box => box.day === day);
    // const totalCost = dayBoxes.reduce((sum, box) => {
    //     const cost = parseFloat(box.cost.replace(/[^0-9]/g, '')) || 0;
    //     return sum + cost;
    // }, 0);
    // return totalCost;
}

// 비용 표시 포맷팅
function formatCost(amount, currency = 'KRW') {
    // TODO: 통화별 포맷팅 및 환율 계산
    // if (currency === 'KRW') {
    //     return amount.toLocaleString() + '원';
    // } else if (currency === 'USD') {
    //     return '$' + amount.toFixed(2);
    // } else if (currency === 'JPY') {
    //     return '¥' + amount.toLocaleString();
    // } else if (currency === 'EUR') {
    //     return '€' + amount.toFixed(2);
    // }
    // 환율 계산된 금액도 표시
    // const convertedAmount = amount * exchangeRate;
    // return `${foreignCurrency} (${convertedToKRW}원)`;
}

// 날짜 컬럼 생성
function createDayColumns() {
    tempPlacedBoxes = {};
    Object.keys(placedBoxes).forEach(day => {
        tempPlacedBoxes[day] = [...placedBoxes[day]];
    });
    
    const container = document.getElementById('dayColumns');
    if (!container) {
        console.error('dayColumns container not found!');
        return;
    }
    container.innerHTML = '';
    
    const startDateInput = document.getElementById('startDate');
    if (!startDateInput) {
        console.error('startDate input not found!');
        return;
    }
    const startDate = new Date(startDateInput.value || '2025-01-15');
    
    placedBoxes = {};
    occupiedSlots = {};
    
    for (let day = 0; day < totalDays; day++) {
        const currentDate = new Date(startDate);
        currentDate.setDate(startDate.getDate() + day);
        
        const dayColumn = document.createElement('div');
        dayColumn.className = 'day-column';
        dayColumn.dataset.day = day;
        
        const dayHeader = document.createElement('div');
        dayHeader.className = 'day-header';
        dayHeader.innerHTML = `
            <div>${currentDate.getMonth() + 1}/${currentDate.getDate()} Day${day + 1}</div>
            <!-- TODO: 비용 합계 표시 영역 -->
            <!-- <div class="day-cost-summary" style="font-size: 11px; color: #1976D2; margin-top: 4px; font-weight: 500;">
                <span style="display: inline-block; background: #e3f2fd; padding: 2px 6px; border-radius: 4px;">
                    합계: <span class="cost-amount">0원</span>
                </span>
            </div> -->
        `;
        dayColumn.appendChild(dayHeader);
        
        const timeGrid = document.createElement('div');
        timeGrid.className = 'time-grid';
        
        const actualStart = extendedStart !== null ? extendedStart : timeRangeStart;
        const actualEnd = extendedEnd !== null ? extendedEnd : timeRangeEnd;
        
        for (let hour = actualStart; hour < actualEnd; hour++) {
            const slot = document.createElement('div');
            slot.className = 'time-slot';
            slot.dataset.hour = hour;
            slot.dataset.minute = 0;
            slot.dataset.totalMinutes = hour * 60;
            timeGrid.appendChild(slot);
        }
        
        dayColumn.appendChild(timeGrid);
        container.appendChild(dayColumn);
        
        placedBoxes[day] = [];
        occupiedSlots[day] = {};
    }
    
    restorePlacedBoxes();
    setupDragDropEvents();
}

// 배치된 박스 복원
function restorePlacedBoxes() {
    Object.keys(tempPlacedBoxes).forEach(day => {
        const boxesData = tempPlacedBoxes[day];
        if (parseInt(day) < totalDays) {
            boxesData.forEach(boxData => {
                if (boxData) {
                    // 저장된 데이터로 완전한 박스 데이터 생성
                    const completeData = {
                        id: boxData.id || Date.now(),
                        title: boxData.title || '',
                        category: boxData.category || 'activity',
                        startHour: boxData.hour,
                        startMinute: boxData.minute,
                        durationHour: Math.floor(boxData.duration / 60),
                        durationMinute: boxData.duration % 60,
                        cost: boxData.cost || '',
                        memo: boxData.memo || '',
                        location: boxData.location || '',
                        locationData: boxData.locationData || null
                    };
                    
                    // createPlacedBox 함수를 사용하여 박스 생성
                    createPlacedBox(completeData, parseInt(day), boxData.hour, boxData.minute, boxData.isClone);
                }
            });
        }
    });
    tempPlacedBoxes = {};
    
}

// 박스 크기 클래스 업데이트
function updateBoxSizeClass(box, height) {
    // 모든 크기 클래스 제거
    box.classList.remove('tiny', 'compact', 'medium');
    
    // 높이에 따라 적절한 클래스 추가
    if (height <= 30) {
        box.classList.add('compact');
    } else if (height <= 40) {
        box.classList.add('medium');
    }
    // 50분 이상은 일반 크기로 클래스 없음
}

// 박스 높이에 따른 메모 줄 수 계산
function calculateMemoLines(boxHeight) {
    // 고정 요소들의 정확한 높이 계산
    // 패딩: 4px * 2 = 8px
    // 시간 헤더: 18px (font-size: 14px + margin-bottom: 2px + padding)
    // 제목: 20px (font-size: 15px + padding)
    // 하단 위치 (있는 경우): 15px (font-size: 11px + padding)
    // 하단 비용 (있는 경우): 20px (font-size: 11px + margin-top: 3px + padding-top: 3px + border: 1px)
    // 버퍼 공간: 5px (완전한 줄만 표시하기 위한 여유)
    
    const paddingVertical = 8; // 상하 패딩
    const timeHeader = 20; // 시간 헤더 영역
    const titleHeight = 22; // 제목 영역
    const bottomSection = 40; // 위치 + 비용 영역 (넉넉하게)
    const buffer = 5; // 안전 버퍼
    
    const totalFixedHeight = paddingVertical + timeHeader + titleHeight + bottomSection + buffer;
    
    const lineHeight = 15.4; // 11px font * 1.4 line-height
    
    // 메모에 사용 가능한 높이
    const availableHeight = boxHeight - totalFixedHeight;
    
    // 최대 줄 수 계산 (최소 1줄, 최대 10줄)
    // Math.floor로 완전한 줄만 표시
    let maxLines = Math.floor(availableHeight / lineHeight);
    
    // 최소 1줄, 최대 10줄로 제한
    maxLines = Math.max(1, Math.min(10, maxLines));
    
    // 디버깅용 로그 (필요시 주석 해제)
    // console.log(`Box height: ${boxHeight}px, Available: ${availableHeight}px, Lines: ${maxLines}`);
    
    return maxLines;
}

// 샘플 데이터 로드
function loadSampleData() {
    planboxData = [
        {
            id: 1,
            title: '공항 출발',
            category: 'transport',
            startHour: 5,
            startMinute: 40,
            durationHour: 2,
            durationMinute: 0,
            cost: '리무진버스 3,000엔',
            memo: '나리타공항에서 신주쿠까지 이동. 사전 예약 필수'
        },
        {
            id: 2,
            title: '호텔 체크인',
            category: 'accommodation',
            startHour: 14,
            startMinute: 0,
            durationHour: 0,
            durationMinute: 0,
            cost: '예약완료',
            memo: '신주쿠 그랜벨 호텔'
        },
        {
            id: 3,
            title: '이치란 라멘',
            category: 'food',
            startHour: 12,
            startMinute: 30,
            durationHour: 1,
            durationMinute: 0,
            cost: '2,000엔',
            memo: '유명한 돈코츠 라멘집. 개인 부스에서 식사'
        },
        {
            id: 4,
            title: '심야버스',
            category: 'transport',
            startHour: 23,
            startMinute: 30,
            durationHour: 7,
            durationMinute: 0,
            cost: '8,000엔',
            memo: '도쿄→오사카 심야버스'
        }
    ];
    
    renderPlanboxList();
}

// 플랜박스 목록 렌더링
function renderPlanboxList() {
    const container = document.getElementById('planboxList');
    container.innerHTML = '';
    
    // 필터링 적용
    const filteredData = currentCategoryFilter === 'all' 
        ? planboxData 
        : planboxData.filter(box => box.category === currentCategoryFilter);
    
    if (filteredData.length === 0 && currentCategoryFilter !== 'all') {
        container.innerHTML = `<div style="padding: 20px; text-align: center; color: #6c757d; font-size: 13px;">
            선택한 카테고리의 플랜박스가 없습니다.
        </div>`;
        return;
    }
    
    filteredData.forEach(box => {
        const element = createPlanboxElement(box);
        container.appendChild(element);
    });
}

// 카테고리 필터링 함수
function filterByCategory(category) {
    currentCategoryFilter = category;
    renderPlanboxList();
    console.log(`필터 적용: ${category === 'all' ? '전체' : category}`);
}

// 플랜박스 요소 생성
function createPlanboxElement(data) {
    const div = document.createElement('div');
    div.className = `planbox-item ${data.category}`;
    div.draggable = true;
    div.dataset.id = data.id;
    
    // 새벽 시간대 체크
    if (data.startHour >= 0 && data.startHour < 6) {
        div.classList.add('dawn-time');
    }
    
    if (cloneSourceId === data.id) {
        div.classList.add('cloneable');
    }
    
    const duration = data.durationHour * 60 + data.durationMinute;
    const durationText = formatDuration(data.durationHour, data.durationMinute);
    
    // 시간 미설정 처리 (hasTimeSet 플래그가 없는 기존 데이터 호환성 고려)
    const hasValidTime = data.startHour !== null && data.startHour !== undefined && 
                        data.startMinute !== null && data.startMinute !== undefined;
    const isTimeSet = data.hasTimeSet !== undefined ? data.hasTimeSet : hasValidTime;
    
    const timeText = (!isTimeSet || !hasValidTime) 
        ? '시간 미설정' 
        : `${data.startHour.toString().padStart(2, '0')}:${data.startMinute.toString().padStart(2, '0')}`;
    
    const endMinutes = (data.startHour !== null && data.startMinute !== null) 
        ? data.startHour * 60 + data.startMinute + duration 
        : 0;
    const endHour = endMinutes > 0 ? Math.floor(endMinutes / 60) % 24 : 0;
    const endMinute = endMinutes > 0 ? endMinutes % 60 : 0;
    const endTimeText = (data.startHour !== null && data.startMinute !== null) 
        ? `${endHour.toString().padStart(2, '0')}:${endMinute.toString().padStart(2, '0')}`
        : '';
    
    // 사이드바 플랜박스 컴팩트 레이아웃
    div.innerHTML = `
        <div style="position: relative; padding: 2px;">
            <!-- 상단: 시간 + 제목 -->
            <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 3px;">
                <span class="planbox-time" style="font-size: 12px; color: #555;">${timeText}</span>
                <div class="planbox-title" style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-size: 13px;">${data.title}</div>
            </div>
            
            <!-- 소요시간 -->
            <div style="text-align: right; margin-bottom: 2px;">
                <span class="planbox-duration" style="font-size: 10px; color: #888; background: rgba(0,0,0,0.05); padding: 1px 4px; border-radius: 4px;">${durationText}</span>
            </div>
            
            <!-- 메모 (있을 경우만 표시) -->
            ${data.memo ? `<div class="planbox-memo" style="font-size: 11px; color: #555; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin-bottom: 2px;">📝 ${data.memo}</div>` : ''}
            
            <!-- 비용 (있을 경우만 표시) -->
            ${data.cost ? `<div class="planbox-cost" style="font-size: 11px; color: #2E7D32;">💰 ${data.cost}</div>` : ''}
            
            <!-- 위치 (있을 경우만 표시) -->
            ${data.location ? `<div class="planbox-location" style="font-size: 11px; color: #1976D2; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">📍 ${data.location}</div>` : ''}
            
            <!-- 컨트롤 버튼들 -->
            <div class="planbox-controls" style="position: absolute; top: 0; right: 0; display: none; gap: 4px;">
                <button class="planbox-control clone ${cloneSourceId === data.id ? 'active' : ''}" 
                        onclick="toggleCloneMode(${data.id})" title="복사 모드">
                    <span class="material-icons" style="font-size: 16px;">content_copy</span>
                </button>
                <button class="planbox-control view" onclick="editPlanbox(${data.id})" title="편집">
                    <span class="material-icons" style="font-size: 16px;">edit</span>
                </button>
            </div>
        </div>
    `;
    
    return div;
}

// 빈 공간 시간 표시 업데이트 함수
function updateGapIndicators(day) {
    const dayColumn = document.querySelectorAll('.day-column')[day];
    if (!dayColumn) return;
    
    // 기존 gap indicators 제거
    dayColumn.querySelectorAll('.gap-indicator').forEach(indicator => {
        indicator.remove();
    });
    
    // 해당 날짜의 모든 박스를 시간 순서대로 정렬
    const boxes = dayColumn.querySelectorAll('.placed-box');
    if (boxes.length === 0) return;
    
    const sortedBoxes = Array.from(boxes).sort((a, b) => {
        const aMinutes = parseInt(a.dataset.hour) * 60 + parseInt(a.dataset.minute);
        const bMinutes = parseInt(b.dataset.hour) * 60 + parseInt(b.dataset.minute);
        return aMinutes - bMinutes;
    });
    
    // 박스 사이의 간격 계산 및 표시
    for (let i = 0; i < sortedBoxes.length - 1; i++) {
        const currentBox = sortedBoxes[i];
        const nextBox = sortedBoxes[i + 1];
        
        const currentEnd = parseInt(currentBox.dataset.hour) * 60 + 
                          parseInt(currentBox.dataset.minute) + 
                          parseInt(currentBox.dataset.duration);
        const nextStart = parseInt(nextBox.dataset.hour) * 60 + 
                         parseInt(nextBox.dataset.minute);
        
        const gapMinutes = nextStart - currentEnd;
        
        // 10분 이상의 간격이 있을 때만 표시
        if (gapMinutes >= 10) {
            const indicator = document.createElement('div');
            indicator.className = 'gap-indicator';
            
            // 위치 계산
            const actualStart = extendedStart !== null ? extendedStart : timeRangeStart;
            const topPosition = ((currentEnd - actualStart * 60) / 60) * 60 + 48;
            const height = (gapMinutes / 60) * 60;
            
            indicator.style.top = topPosition + 'px';
            indicator.style.height = height + 'px';
            
            // 간격 시간 텍스트
            const gapHours = Math.floor(gapMinutes / 60);
            const gapMins = gapMinutes % 60;
            let gapText = '';
            
            if (gapHours > 0 && gapMins > 0) {
                gapText = `${gapHours}시간 ${gapMins}분`;
            } else if (gapHours > 0) {
                gapText = `${gapHours}시간`;
            } else {
                gapText = `${gapMins}분`;
            }
            
            // 간격이 30픽셀 이상일 때만 선과 텍스트 표시
            if (height >= 30) {
                indicator.innerHTML = `
                    <div class="gap-line-top"></div>
                    <div class="gap-time">${gapText}</div>
                    <div class="gap-line-bottom"></div>
                `;
            } else if (height >= 20) {
                // 작은 간격일 때는 텍스트만 표시
                indicator.innerHTML = `<div class="gap-time">${gapText}</div>`;
            }
            
            dayColumn.appendChild(indicator);
        }
    }
}

// 시간 포맷팅
function formatDuration(hours, minutes) {
    if (hours === 0) {
        if (minutes === 10) return '10분';
        else if (minutes === 20) return '20분';
        else if (minutes === 30) return '30분';
        else if (minutes === 40) return '40분';
        else if (minutes === 50) return '50분';
        else return `${minutes}분`;
    } else if (minutes === 0) {
        return `${hours}시간`;
    } else {
        if (minutes === 10) return `${hours}시간 10분`;
        else if (minutes === 20) return `${hours}시간 20분`;
        else if (minutes === 30) return `${hours}시간 30분`;
        else if (minutes === 40) return `${hours}시간 40분`;
        else if (minutes === 50) return `${hours}시간 50분`;
        else return `${hours}시간 ${minutes}분`;
    }
}

// 드래그 오버레이와 배지 생성
// 드래그 중 시간 표시 요소 생성/업데이트
function updateDraggingPlanboxTime(hour, minute) {
    if (!draggedElement || !draggedData) return;
    
    let timeDisplay = document.getElementById('drag-time-display');
    if (!timeDisplay) {
        timeDisplay = document.createElement('div');
        timeDisplay.id = 'drag-time-display';
        timeDisplay.style.cssText = `
            position: fixed;
            background: #ff4757;
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            z-index: 999999;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            border: 2px solid white;
            min-width: 120px;
            text-align: center;
        `;
        document.body.appendChild(timeDisplay);
    }
    
    const timeText = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
    const duration = draggedData.durationHour * 60 + draggedData.durationMinute;
    const endMinutes = hour * 60 + minute + duration;
    const endHour = Math.floor(endMinutes / 60) % 24;
    const endMinute = endMinutes % 60;
    const endTimeText = `${endHour.toString().padStart(2, '0')}:${endMinute.toString().padStart(2, '0')}`;
    
    timeDisplay.textContent = `${timeText} ~ ${endTimeText}`;
    timeDisplay.style.display = 'block';  // 강제로 표시
    timeDisplay.style.visibility = 'visible';  // 확실히 보이도록
}

// 드래그 시간 표시 제거
function removeDragTimeDisplay() {
    const timeDisplay = document.getElementById('drag-time-display');
    if (timeDisplay) {
        timeDisplay.remove();
    }
}

// 원래 시간 복원
function restorePlanboxTime(element) {
    if (!element || !originalTimeDisplay) return;
    
    const timeElement = element.querySelector('.planbox-time');
    if (timeElement) {
        timeElement.innerHTML = originalTimeDisplay;
    }
}

// 드래그 시작 시 원래 시간 저장
function saveOriginalTime(element) {
    const timeElement = element.querySelector('.planbox-time');
    if (timeElement) {
        originalTimeDisplay = timeElement.innerHTML;
    }
}

// 복사 모드 토글
function toggleCloneMode(id) {
    if (cloneSourceId === id) {
        cloneSourceId = null;
        isCloneMode = false;
    } else {
        cloneSourceId = id;
        isCloneMode = true;
    }
    renderPlanboxList();
}

// 이벤트 리스너 설정
function setupEventListeners() {
    setupDragDropEvents();
    // setupResizeEvents는 init()에서 한 번만 호출됨
}

// 모바일 터치 이벤트 지원 추가
function addTouchSupport() {
    // 터치 디바이스 감지
    const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    
    if (isTouchDevice) {
        console.log('터치 디바이스 감지 - 터치 이벤트 활성화');
        
        // 터치 시작 시 드래그 시뮬레이션
        document.addEventListener('touchstart', (e) => {
            const touch = e.touches[0];
            const target = document.elementFromPoint(touch.clientX, touch.clientY);
            
            if (target && (target.classList.contains('planbox-item') || target.classList.contains('placed-box'))) {
                // 터치 드래그 처리를 위한 플래그
                target.setAttribute('data-touch-drag', 'true');
            }
        }, { passive: false });
    }
}

// 드래그 앤 드롭 이벤트
function setupDragDropEvents() {
    // 터치 지원 추가
    addTouchSupport();
    
    document.addEventListener('dragstart', (e) => {
        // 왼쪽 리스트의 플랜박스
        if (e.target.classList.contains('planbox-item')) {
            draggedElement = e.target;
            draggedData = planboxData.find(box => box.id == e.target.dataset.id);
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            isFirstDrop = true;
            
            // 플랜박스 크기만큼의 투명한 드래그 이미지 생성
            if (draggedData) {
                const canvas = document.createElement('canvas');
                const duration = draggedData.durationHour * 60 + draggedData.durationMinute;
                const height = (duration / 60) * 60;
                canvas.width = 200;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                ctx.globalAlpha = 0.01; // 거의 투명
                ctx.fillStyle = '#4a90e2';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                e.dataTransfer.setDragImage(canvas, 100, height/2);
            }
            
            // 원래 시간 저장
            saveOriginalTime(e.target);
        } else if (e.target.classList.contains('placed-box')) {
            draggedElement = e.target;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            isFirstDrop = false;
            
            // 드래그 시작 시 모든 gap indicator 숨기기
            document.querySelectorAll('.gap-indicator').forEach(indicator => {
                indicator.style.display = 'none';
            });
            
            const dataId = parseInt(e.target.dataset.dataId);
            draggedData = {
                id: dataId,
                title: e.target.querySelector('.placed-box-title')?.textContent || e.target.dataset.title || '',
                category: e.target.className.split(' ').find(c => ['food', 'transport', 'activity', 'accommodation', 'shopping', 'sightseeing'].includes(c)) || 'activity',
                startHour: parseInt(e.target.dataset.hour),
                startMinute: parseInt(e.target.dataset.minute),
                durationHour: Math.floor(parseInt(e.target.dataset.duration) / 60),
                durationMinute: parseInt(e.target.dataset.duration) % 60,
                cost: e.target.querySelector('.placed-box-info')?.textContent?.replace('💰 ', '') || e.target.dataset.cost || '',
                memo: e.target.dataset.memo || '',
                location: e.target.querySelector('.placed-box-location')?.textContent?.replace('📍 ', '') || e.target.dataset.location || ''
            };
            
            // 배치된 박스도 크기만큼의 투명한 드래그 이미지 생성
            const canvas = document.createElement('canvas');
            const duration = parseInt(e.target.dataset.duration);
            const height = (duration / 60) * 60;
            canvas.width = 200;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.globalAlpha = 0.01; // 거의 투명
            ctx.fillStyle = '#4a90e2';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            e.dataTransfer.setDragImage(canvas, 100, height/2);
            
            // 원래 시간 저장
            saveOriginalTime(e.target);
        }
    });
    
    
    document.addEventListener('dragend', (e) => {
        if (e.target.classList.contains('planbox-item') || e.target.classList.contains('placed-box')) {
            e.target.classList.remove('dragging');
        }
        // clearDragOverEffects(); // 그림자 효과 제거됨
        removeDragGhost(); // 고스트 제거
        
        // 드롭 없이 드래그 종료 시 원래 시간 복원 (지연 실행으로 드롭 이벤트 우선)
        setTimeout(() => {
            if (draggedElement && originalTimeDisplay) {
                restorePlanboxTime(draggedElement);
            }
            removeDragTimeDisplay();
            removeDragGhost(); // 고스트 확실히 제거
            
            // 드래그 종료 시 모든 날짜의 gap indicator 업데이트
            for (let day = 0; day < 7; day++) {
                updateGapIndicators(day);
            }
            
            originalTimeDisplay = null;
            draggedElement = null;
            draggedData = null;
            isFirstDrop = true;
        }, 100);
    });
    
    document.querySelectorAll('.time-slot').forEach(slot => {
        slot.addEventListener('dragover', handleSlotDragOver);
        slot.addEventListener('dragleave', handleSlotDragLeave);
        slot.addEventListener('drop', handleSlotDrop);
    });
    
    // day-column에서도 드래그 이벤트 처리 (고스트 유지)
    document.querySelectorAll('.day-column').forEach(column => {
        column.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            // 마우스가 time-slot 밖에 있을 때도 고스트 유지
            const rect = column.getBoundingClientRect();
            const relativeY = e.clientY - rect.top - 48; // 헤더 높이 제외
            
            if (relativeY >= 0 && draggedElement && draggedData) {
                const actualStart = extendedStart !== null ? extendedStart : timeRangeStart;
                const minutesFromStart = Math.floor((relativeY / 60) * 60);
                const totalMinutes = actualStart * 60 + minutesFromStart;
                let hour = Math.floor(totalMinutes / 60);
                let minute = Math.round((totalMinutes % 60) / 10) * 10; // 10분 단위로 반올림 스냅
                
                // 60분이 되면 다음 시간으로 넘어감
                if (minute >= 60) {
                    hour += 1;
                    minute = 0;
                }
                
                updateDraggingPlanboxTime(hour, minute);
                
                // 가상의 slot 객체 생성
                const fakeSlot = {
                    closest: () => column,
                    dataset: { hour: hour }
                };
                updateDragGhost(fakeSlot, hour, minute, draggedData);
            }
        });
    });
    
    const planboxList = document.getElementById('planboxList');
    planboxList.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
    });
    
    planboxList.addEventListener('drop', (e) => {
        e.preventDefault();
        
        if (draggedElement && draggedElement.classList.contains('placed-box')) {
            returnToSidebar(draggedElement);
        }
        
        // 사이드바 드롭 성공 후 변수 초기화
        removeDragTimeDisplay();
        removeDragGhost(); // 고스트 제거
        originalTimeDisplay = null;
        draggedElement = null;
        draggedData = null;
        isFirstDrop = true;
    });
}

// 리사이즈 이벤트
function setupResizeEvents() {
    console.log('===== setupResizeEvents 함수 실행됨 (TOP & BOTTOM RESIZE) =====');
    
    let isResizing = false;
    let resizeBox = null;
    let resizeDirection = null; // 'top' or 'bottom'
    let startY = 0;
    let startHeight = 0;
    let startTop = 0;
    let lastUpdateHeight = 0; // 마지막 업데이트 시의 높이 추적
    let updateThrottle = null; // 업데이트 throttle 타이머
    
    // 모든 placed-box에 대해 이벤트 위임 사용
    document.addEventListener('mousemove', (e) => {
        const box = e.target.closest('.placed-box');
        
        if (!isResizing && box && !box.classList.contains('dragging')) {
            const rect = box.getBoundingClientRect();
            const y = e.clientY - rect.top;
            
            // 상단 10px 영역 또는 하단 10px 영역이면 리사이즈 커서
            if (y <= 10 || y >= rect.height - 10) {
                box.style.cursor = 'ns-resize';
            } else {
                box.style.cursor = 'move';
            }
        }
        
        // 리사이징 중
        if (isResizing && resizeBox) {
            e.preventDefault();
            const deltaY = e.clientY - startY;
            
            if (resizeDirection === 'bottom') {
                // 하단 리사이즈
                let newHeight = Math.max(30, startHeight + deltaY); // 최소 30px (30분)
                
                // 10분 단위로 스냅 (10px = 10분)
                newHeight = Math.round(newHeight / 10) * 10;
                newHeight = Math.max(30, newHeight); // 최소 30분
                
                // 테이블 하단(24:00)을 벗어나지 않도록 제한
                const dayColumn = resizeBox.closest('.day-column');
                const boxTop = parseInt(resizeBox.style.top);
                // 24시까지의 총 높이: (24 - timeRangeStart) * 60px + 헤더 48px
                const actualStart = extendedStart !== null ? extendedStart : timeRangeStart;
                const totalHeight = (24 - actualStart) * 60 + 48;
                const maxHeight = totalHeight - boxTop;
                newHeight = Math.min(newHeight, maxHeight);
                
                resizeBox.style.height = newHeight + 'px';
                
                // 리사이즈 중에도 메모 라인 수를 실시간으로 업데이트 (throttled)
                if (newHeight > 60 && Math.abs(newHeight - lastUpdateHeight) >= 15) { // 15px 이상 변경 시만 업데이트
                    clearTimeout(updateThrottle);
                    updateThrottle = setTimeout(() => {
                        updatePlacedBoxContent(resizeBox);
                        lastUpdateHeight = newHeight;
                    }, 50); // 50ms throttle
                }
            } else if (resizeDirection === 'top') {
                // 상단 리사이즈
                let newHeight = Math.max(30, startHeight - deltaY); // 최소 30px (30분)
                let newTop = startTop + deltaY;
                
                // 10분 단위로 스냅
                const deltaHeight = Math.round((startHeight - newHeight) / 10) * 10;
                newHeight = startHeight - deltaHeight;
                newTop = startTop + deltaHeight;
                
                // 최소 30분 보장, 상단 경계 체크
                if (newHeight >= 30 && newTop >= 48) { // 헤더 아래로만
                    resizeBox.style.height = newHeight + 'px';
                    resizeBox.style.top = newTop + 'px';
                    
                    // 리사이즈 중에도 메모 라인 수를 실시간으로 업데이트 (throttled)
                    if (newHeight > 60 && Math.abs(newHeight - lastUpdateHeight) >= 15) { // 15px 이상 변경 시만 업데이트
                        clearTimeout(updateThrottle);
                        updateThrottle = setTimeout(() => {
                            updatePlacedBoxContent(resizeBox);
                            lastUpdateHeight = newHeight;
                        }, 50); // 50ms throttle
                    }
                }
            }
        }
    });
    
    // 리사이즈 시작
    document.addEventListener('mousedown', (e) => {
        const box = e.target.closest('.placed-box');
        
        if (box && !box.classList.contains('dragging')) {
            const rect = box.getBoundingClientRect();
            const y = e.clientY - rect.top;
            
            // 상단 10px 또는 하단 10px 영역을 클릭했을 때
            if (y <= 10) {
                // 상단 리사이즈
                e.preventDefault();
                e.stopPropagation(); // 드래그 방지
                
                isResizing = true;
                resizeBox = box;
                resizeDirection = 'top';
                startY = e.clientY;
                startHeight = rect.height;
                startTop = parseInt(box.style.top);
                lastUpdateHeight = rect.height; // 초기 높이 저장
                
                box.classList.add('resizing');
                console.log('상단 리사이즈 시작!', { startHeight, startTop });
            } else if (y >= rect.height - 10) {
                // 하단 리사이즈
                e.preventDefault();
                e.stopPropagation(); // 드래그 방지
                
                isResizing = true;
                resizeBox = box;
                resizeDirection = 'bottom';
                startY = e.clientY;
                startHeight = rect.height;
                lastUpdateHeight = rect.height; // 초기 높이 저장
                
                box.classList.add('resizing');
                console.log('하단 리사이즈 시작!', { startHeight });
            }
        }
    });
    
    // 리사이즈 종료
    document.addEventListener('mouseup', () => {
        if (isResizing && resizeBox) {
            console.log('리사이즈 종료!', resizeDirection);
            
            // duration 업데이트 (10분 단위)
            const newHeight = parseInt(resizeBox.style.height);
            const newDuration = Math.round(newHeight / 10) * 10; // 10px = 10분, 10분 단위로 반올림
            resizeBox.dataset.duration = newDuration;
            
            // 상단 리사이즈인 경우 시작 시간도 업데이트
            if (resizeDirection === 'top') {
                const newTop = parseInt(resizeBox.style.top);
                const deltaTop = newTop - startTop;
                const deltaMinutes = Math.round(deltaTop / 10) * 10; // 10px = 10분
                
                const currentHour = parseInt(resizeBox.dataset.hour);
                const currentMinute = parseInt(resizeBox.dataset.minute);
                const totalMinutes = currentHour * 60 + currentMinute + deltaMinutes;
                
                const newHour = Math.floor(totalMinutes / 60);
                const newMinute = totalMinutes % 60;
                
                // 음수 시간 방지
                if (totalMinutes >= 0) {
                    resizeBox.dataset.hour = newHour;
                    resizeBox.dataset.minute = newMinute;
                    
                    // planboxData 업데이트
                    const dataId = resizeBox.dataset.id;
                    const data = planboxData.find(d => d.id === dataId);
                    if (data) {
                        data.startHour = newHour;
                        data.startMinute = newMinute;
                    }
                }
            }
            
            // 박스 내용 업데이트
            updatePlacedBoxContent(resizeBox);
            
            // 점유 슬롯 업데이트
            const day = parseInt(resizeBox.dataset.day);
            const hour = parseInt(resizeBox.dataset.hour);
            const minute = parseInt(resizeBox.dataset.minute);
            releaseOccupiedSlots(resizeBox);
            occupyTimeSlots(day, hour, minute, newDuration, resizeBox);
            
            resizeBox.classList.remove('resizing');
            resizeBox.style.cursor = 'move';
            
            // planboxData의 duration도 업데이트
            const dataId = resizeBox.dataset.id;
            const data = planboxData.find(d => d.id === dataId);
            if (data) {
                data.durationHour = Math.floor(newDuration / 60);
                data.durationMinute = newDuration % 60;
            }
            
            isResizing = false;
            resizeBox = null;
            resizeDirection = null;
            lastUpdateHeight = 0;
            clearTimeout(updateThrottle); // 타이머 정리
            
            markAsChanged(); // 자동 저장
        }
    });
}

// handleResize와 updateResizedBox 함수는 이제 필요 없음 (위에 통합됨)


// 배치된 박스 내용 업데이트
function updatePlacedBoxContent(box) {
    const hour = parseInt(box.dataset.hour);
    const minute = parseInt(box.dataset.minute);
    const duration = parseInt(box.dataset.duration);
    const title = box.dataset.title || '';
    const cost = box.dataset.cost || '';
    const memo = box.dataset.memo || '';
    const location = box.dataset.location || '';
    
    const startTimeText = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
    const durationHours = Math.floor(duration / 60);
    const durationMinutes = duration % 60;
    const durationText = formatDuration(durationHours, durationMinutes);
    
    const height = parseInt(box.style.height);
    
    // 먼저 모든 크기 클래스 제거
    box.classList.remove('tiny', 'compact', 'medium');
    
    // 소요시간 배지 (50분 이상 ~ 1시간까지만 표시)
    const showDurationBadge = (duration >= 50 && duration <= 60);
    const durationBadge = showDurationBadge ? 
        `<span class="duration-badge" style="position: absolute; bottom: 4px; right: 8px; font-size: 10px; background: rgba(255,255,255,0.9); padding: 2px 5px; border-radius: 8px; color: #666; box-shadow: 0 1px 2px rgba(0,0,0,0.1);">${durationText}</span>` : '';
    
    if (duration <= 40) {
        // 30분, 40분 - 시간과 제목만 (소요시간 표시 안함)
        box.innerHTML = `
            <div style="position: relative; height: 100%; padding: 4px 6px; padding-right: 25px;">
                <div class="placed-box-header" style="display: flex; align-items: center; gap: 4px;">
                    <span class="placed-box-time">${startTimeText}</span>
                    <div class="placed-box-title" style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${title}</div>
                </div>
            </div>
            <div class="placed-box-floating-controls">
                <button class="placed-box-control view" onclick="editPlacedBox(this.parentElement.parentElement)" title="상세정보">
                    <span class="material-icons" style="font-size: 14px;">more_horiz</span>
                </button>
            </div>
        `;
    } else if (duration >= 50 && duration <= 70) {
        // 50분~1시간 10분 - 시간+제목+소요시간, 공간 있으면 짧은 메모
        const canShowMemo = height >= 50 && memo;
        
        box.innerHTML = `
            <div style="position: relative; height: 100%; padding: 4px 6px; padding-right: 25px;">
                <div class="placed-box-header" style="display: flex; align-items: center; gap: 4px; margin-bottom: 2px;">
                    <span class="placed-box-time">${startTimeText}</span>
                    <div class="placed-box-title" style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${title}</div>
                </div>
                
                <div style="text-align: right; margin-bottom: 2px;">
                    <span style="font-size: 10px; color: #888; background: rgba(0,0,0,0.05); padding: 1px 4px; border-radius: 6px;">${durationText}</span>
                </div>
                
                ${canShowMemo ? 
                    `<div style="font-size: 11px; color: #555; line-height: 1.2; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                        📝 ${memo}
                    </div>` : ''
                }
                
                ${cost && height >= 60 ? 
                    `<div style="font-size: 11px; color: #2E7D32; margin-top: 2px;">
                        💰 ${cost}
                    </div>` : ''
                }
            </div>
            <div class="placed-box-floating-controls">
                <button class="placed-box-control view" onclick="editPlacedBox(this.parentElement.parentElement)" title="상세정보">
                    <span class="material-icons" style="font-size: 14px;">more_horiz</span>
                </button>
            </div>
        `;
    } else {
        // 1시간 10분 이상 - 실용적인 여행 스케줄러 레이아웃 (상세 정보)
        // 높이에 따라 메모 줄 수와 표시 정보 결정
        const availableHeight = height - 60; // 헤더와 패딩 제외한 사용 가능 높이
        const lineHeight = 14; // 각 줄의 높이
        const maxMemoLines = Math.max(1, Math.floor(availableHeight / lineHeight) - 2); // 소요시간, 비용 줄 제외
        
        // 공간에 따른 정보 표시 전략
        const showLocation = height >= 120; // 2시간 이상일 때 주소 표시
        const showFullInfo = height >= 90;  // 1.5시간 이상일 때 모든 정보 표시
        
        box.innerHTML = `
            <div style="position: relative; height: 100%; padding: 4px 6px; padding-right: 25px; display: flex; flex-direction: column;">
                <!-- 헤더: 시간 + 제목 -->
                <div class="placed-box-header" style="display: flex; align-items: center; gap: 4px; margin-bottom: 3px;">
                    <span class="placed-box-time">${startTimeText}</span>
                    <div class="placed-box-title" style="flex: 1; line-height: 1.2;">${title}</div>
                </div>
                
                <!-- 소요시간 -->
                <div style="text-align: right; margin-bottom: 3px;">
                    <span style="font-size: 10px; color: #888; background: rgba(0,0,0,0.05); padding: 1px 4px; border-radius: 6px;">${durationText}</span>
                </div>
                
                <!-- 메인 콘텐츠 영역 -->
                <div style="flex: 1; display: flex; flex-direction: column; gap: 2px;">
                    ${memo ? 
                        `<div style="font-size: 11px; color: #555; line-height: 1.3; display: -webkit-box; -webkit-line-clamp: ${maxMemoLines}; -webkit-box-orient: vertical; overflow: hidden;">
                            📝 ${memo}
                        </div>` : ''
                    }
                    
                    ${cost && showFullInfo ? 
                        `<div style="font-size: 11px; color: #2E7D32;">
                            💰 ${cost}
                        </div>` : ''
                    }
                    
                    ${location && showLocation ? 
                        `<div style="font-size: 11px; color: #1976D2; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                            📍 ${location}
                        </div>` : ''
                    }
                </div>
            </div>
            <div class="placed-box-floating-controls">
                <button class="placed-box-control view" onclick="editPlacedBox(this.parentElement.parentElement)" title="상세정보">
                    <span class="material-icons" style="font-size: 14px;">more_horiz</span>
                </button>
            </div>
        `;
    }
}


// 배치된 박스 직접 삭제
function deletePlacedBox(placedBox) {
    if (confirm('이 일정을 삭제하시겠습니까?')) {
        const day = parseInt(placedBox.dataset.day);
        
        // 점유 슬롯 해제
        releaseOccupiedSlots(placedBox);
        
        // 배치된 박스 목록에서 제거
        if (placedBoxes[day]) {
            placedBoxes[day] = placedBoxes[day].filter(b => b !== placedBox);
        }
        
        // DOM에서 제거
        placedBox.remove();
        
        // 간격 표시 업데이트
        updateGapIndicators(day);
        
        // 자동 저장
        markAsChanged();
    }
}

// 사이드바로 반환
function returnToSidebar(placedBox) {
    const day = parseInt(placedBox.dataset.day);
    const dataId = parseInt(placedBox.dataset.dataId);
    
    releaseOccupiedSlots(placedBox);
    
    if (placedBoxes[day]) {
        placedBoxes[day] = placedBoxes[day].filter(b => b !== placedBox);
    }
    
    if (!placedBox.dataset.isClone || placedBox.dataset.isClone === 'false') {
        const originalData = planboxData.find(d => d.id === dataId);
        if (!originalData) {
            const title = placedBox.dataset.title || placedBox.querySelector('.placed-box-title')?.textContent || '';
            const cost = placedBox.dataset.cost || placedBox.querySelector('.placed-box-info')?.textContent || '';
            const duration = parseInt(placedBox.dataset.duration);
            const category = placedBox.className.split(' ').find(c => ['food', 'transport', 'activity', 'accommodation'].includes(c)) || 'activity';
            
            planboxData.push({
                id: dataId,
                title: title,
                category: category,
                startHour: parseInt(placedBox.dataset.hour),
                startMinute: parseInt(placedBox.dataset.minute),
                durationHour: Math.floor(duration / 60),
                durationMinute: duration % 60,
                cost: cost,
                memo: placedBox.dataset.memo || '',
                location: placedBox.dataset.location || ''
            });
        }
        renderPlanboxList();
    }
    
    placedBox.remove();
}

// 슬롯 드래그 오버 처리
function handleSlotDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    
    const slot = e.currentTarget;
    const rect = slot.getBoundingClientRect();
    const relativeY = e.clientY - rect.top;
    const slotHeight = rect.height;
    
    // 그림자 효과 제거 - 고스트와 시간 배지만 사용
    
    // 새벽 시간대는 30분 단위, 그 외는 10분 단위
    let hour = parseInt(slot.dataset.hour);
    const isDawnBlock = false;  // 타임라인이 6시부터 시작하므로 새벽 블록 없음
    
    let minute = 0;
    if (isDawnBlock) {
        // 30분 단위
        const half = slotHeight / 2;
        minute = relativeY < half ? 0 : 30;
    } else {
        // 10분 단위 - 더 정확한 계산
        const minutePerPixel = 60 / slotHeight;  // 1픽셀당 분
        const calculatedMinute = relativeY * minutePerPixel;  // 계산된 분
        let roundedMinute = Math.round(calculatedMinute / 10) * 10;  // 10분 단위로 반올림
        
        // 23시 슬롯의 경우 특별 처리 - 24:00까지 가능
        if (hour === 23) {
            // 23:00~23:50 범위 허용 (24:00까지 배치 가능)
            minute = Math.min(roundedMinute, 50);
        } else if (roundedMinute >= 60) {
            // 다른 시간대에서 60분이 되면 다음 시간으로
            hour += 1;
            roundedMinute = 0;
            minute = roundedMinute;
        } else {
            minute = roundedMinute;
        }
    }
    
    // 드래그 중인 플랜박스의 시간 업데이트 및 고스트 표시
    if (draggedElement && draggedData) {
        updateDraggingPlanboxTime(hour, minute);
        
        // 드래그 고스트 생성/업데이트
        updateDragGhost(slot, hour, minute, draggedData);
        
        // 시간 표시를 마우스에서 떨어진 위치로 이동 (플랜박스 ghost에 가려지지 않도록)
        const timeDisplay = document.getElementById('drag-time-display');
        if (timeDisplay) {
            timeDisplay.style.left = (e.clientX + 50) + 'px'; // 오른쪽으로 50px 이동
            timeDisplay.style.top = (e.clientY - 30) + 'px';  // 위쪽으로 30px 이동
        }
    }
}

// 드래그 고스트 업데이트
function updateDragGhost(slot, hour, minute, data) {
    const dayColumn = slot.closest('.day-column');
    if (!dayColumn) return;
    
    const day = parseInt(dayColumn.dataset.day);
    
    // 기존 고스트 제거
    removeDragGhost();
    
    // 새 고스트 생성
    const ghost = document.createElement('div');
    ghost.id = 'drag-ghost';
    ghost.className = `drag-ghost ${data.category || 'activity'}`;
    
    // 고스트 크기 계산
    const duration = data.durationHour * 60 + data.durationMinute;
    const height = (duration / 60) * 60; // 1시간 = 60px
    
    // 위치 계산 (10분 단위로 스냅)
    const actualStart = extendedStart !== null ? extendedStart : timeRangeStart;
    const totalMinutes = hour * 60 + minute;
    const top = ((totalMinutes - actualStart * 60) / 60) * 60 + 48;
    
    ghost.style.height = `${height}px`;
    ghost.style.top = `${top}px`;
    ghost.style.left = '0';  // 타임셀에 정확히 맞춤
    ghost.style.right = '0'; // 타임셀에 정확히 맞춤
    
    // 시간 텍스트 표시
    const adjustedHours = Math.floor(duration / 60);
    const adjustedMinutes = duration % 60;
    const durationText = formatDuration(adjustedHours, adjustedMinutes);
    ghost.innerHTML = `${data.title}<br>${durationText}`;
    
    dayColumn.appendChild(ghost);
}

// 드래그 고스트 제거
function removeDragGhost() {
    const ghost = document.getElementById('drag-ghost');
    if (ghost) {
        ghost.remove();
    }
}

// 드래그 오버 효과 제거
function clearDragOverEffects() {
    document.querySelectorAll('.drag-over').forEach(el => {
        el.classList.remove('drag-over', 'drag-over-10', 'drag-over-20', 'drag-over-30', 'drag-over-40', 'drag-over-50', 'drag-over-60');
    });
    // 고스트는 여기서 제거하지 않음 (드래그가 끝날 때만 제거)
}

// 슬롯 드래그 떠남
function handleSlotDragLeave(e) {
    e.currentTarget.classList.remove('drag-over', 'drag-over-10', 'drag-over-20', 'drag-over-30', 'drag-over-40', 'drag-over-50', 'drag-over-60');
}

// 슬롯에 드롭
function handleSlotDrop(e) {
    e.preventDefault();
    // clearDragOverEffects(); // 그림자 효과 제거됨
    
    const slot = e.currentTarget;
    const rect = slot.getBoundingClientRect();
    const relativeY = e.clientY - rect.top;
    const slotHeight = rect.height;
    
    const dayColumn = slot.closest('.day-column');
    const day = parseInt(dayColumn.dataset.day);
    let hour = parseInt(slot.dataset.hour);
    
    // 새벽 시간대는 30분 단위, 그 외는 10분 단위
    const isDawnBlock = false;  // 타임라인이 6시부터 시작하므로 새벽 블록 없음
    let minute = 0;
    
    if (isDawnBlock) {
        const half = slotHeight / 2;
        minute = relativeY < half ? 0 : 30;
    } else {
        // 10분 단위 - dragOver와 동일한 정확한 계산
        const minutePerPixel = 60 / slotHeight;  // 1픽셀당 분
        const calculatedMinute = relativeY * minutePerPixel;  // 계산된 분
        let roundedMinute = Math.round(calculatedMinute / 10) * 10;  // 10분 단위로 반올림
        
        // 23시 슬롯의 경우 특별 처리 - 24:00까지 가능
        if (hour === 23) {
            // 23:00~23:50 범위 허용 (24:00까지 배치 가능)
            minute = Math.min(roundedMinute, 50);
        } else if (roundedMinute >= 60) {
            // 다른 시간대에서 60분이 되면 다음 시간으로
            hour += 1;
            roundedMinute = 0;
            minute = roundedMinute;
        } else {
            minute = roundedMinute;
        }
    }
    
    if (draggedElement && draggedElement.classList.contains('planbox-item')) {
        if (draggedData) {
            if (isFirstDrop) {
                // hasTimeSet 플래그 또는 null 값으로 시간 미설정 판단
                if (draggedData.hasTimeSet === false || 
                    draggedData.startHour === null || draggedData.startMinute === null) {
                    // 시간이 미설정된 경우 드롭 위치 시간을 사용
                    // hour와 minute은 이미 드롭 위치에 따라 설정됨
                } else if (draggedData.startHour >= 0 && draggedData.startMinute >= 0) {
                    // 시간이 설정된 경우 기존 시간을 사용하되 10분 단위로 스냅
                    hour = draggedData.startHour;
                    minute = Math.round(draggedData.startMinute / 10) * 10;
                    
                    // 시간이 설정된 박스를 처음 드롭할 때 충돌 확인
                    const duration = draggedData.durationHour * 60 + draggedData.durationMinute;
                    if (checkTimeConflict(day, hour, minute, duration, null)) {
                        // 충돌 발생 시 처리 옵션
                        const conflictResolution = confirm(
                            `${hour}:${minute.toString().padStart(2, '0')}에 이미 다른 일정이 있습니다.\n\n` +
                            `확인: 가장 가까운 빈 시간으로 자동 배치\n` +
                            `취소: 드롭 위치의 시간으로 변경`
                        );
                        
                        if (conflictResolution) {
                            // 가장 가까운 빈 시간 찾기
                            const nearestEmpty = findNearestEmptySlot(day, hour, minute, duration);
                            if (nearestEmpty) {
                                hour = nearestEmpty.hour;
                                minute = nearestEmpty.minute;
                            } else {
                                alert('이 날짜에 충분한 빈 시간이 없습니다.');
                                return; // 드롭 취소
                            }
                        } else {
                            // 드롭 위치의 시간으로 변경 (이미 설정됨)
                            // 원래 드롭 위치 시간 사용
                            const rect = slot.getBoundingClientRect();
                            const relativeY = Math.max(0, e.clientY - rect.top);
                            const slotHeight = rect.height;
                            const minutePerPixel = 60 / slotHeight;
                            const calculatedMinute = relativeY * minutePerPixel;
                            let roundedMinute = Math.round(calculatedMinute / 10) * 10;
                            
                            if (roundedMinute >= 60) {
                                hour += 1;
                                roundedMinute = 0;
                            }
                            minute = roundedMinute;
                        }
                    }
                }
                
                // 24시를 넘어가지 않도록 체크 (24시까지는 배치 허용)
                const endTime = hour + Math.ceil((minute + draggedData.durationHour * 60 + draggedData.durationMinute) / 60);
                if (hour < timeRangeStart || endTime > 24) {
                    checkExtendedTimeRange();
                    createTimeLabels();
                    createDayColumns();
                } else if (endTime > timeRangeEnd && endTime <= 24) {
                    // 기본 시간 범위를 넘지만 24시는 넘지 않는 경우 확장
                    checkExtendedTimeRange();
                    createTimeLabels();
                    createDayColumns();
                }
            }
            
            if (isCloneMode && cloneSourceId === draggedData.id) {
                const clonedData = {...draggedData, id: Date.now()};
                createPlacedBox(clonedData, day, hour, minute, true);
            } else {
                createPlacedBox(draggedData, day, hour, minute);
                const index = planboxData.findIndex(b => b.id === draggedData.id);
                if (index !== -1) {
                    planboxData.splice(index, 1);
                    renderPlanboxList();
                }
            }
        }
    } else if (draggedElement && draggedElement.classList.contains('placed-box')) {
        movePlacedBox(draggedElement, day, hour, minute);
    }
    
    // 드롭 성공 후 변수 초기화
    removeDragTimeDisplay();
    removeDragGhost(); // 고스트 제거
    originalTimeDisplay = null;
    draggedElement = null;
    draggedData = null;
    isFirstDrop = true;
    
    // 드롭 성공 후 모든 날짜의 gap indicator 업데이트
    for (let day = 0; day < 7; day++) {
        updateGapIndicators(day);
    }
}

// 배치된 박스 생성
function createPlacedBox(data, day, hour, minute, isClone = false) {
    markAsChanged(); // 자동 저장을 위한 변경 표시
    const dayColumn = document.querySelectorAll('.day-column')[day];
    if (!dayColumn) return;
    
    // 충돌 검사 및 자동 스냅
    const duration = data.durationHour * 60 + data.durationMinute;
    const startMinutes = hour * 60 + minute;
    
    if (checkTimeConflict(day, hour, minute, duration, null)) {
        // 충돌하는 박스 찾기
        const conflictBox = findConflictingBox(day, startMinutes, duration);
        
        if (conflictBox) {
            const conflictStart = parseInt(conflictBox.dataset.hour) * 60 + parseInt(conflictBox.dataset.minute);
            const conflictEnd = conflictStart + parseInt(conflictBox.dataset.duration);
            const dropCenter = startMinutes + duration / 2;
            const conflictCenter = conflictStart + parseInt(conflictBox.dataset.duration) / 2;
            
            // 드롭 위치가 기존 박스의 아래쪽인지 위쪽인지 판단
            if (dropCenter > conflictCenter) {
                // 아래쪽에 드롭 - 기존 박스 종료시간에 시작
                const newHour = Math.floor(conflictEnd / 60);
                const newMinute = conflictEnd % 60;
                const newEndTime = newHour + Math.ceil((newMinute + duration) / 60);
                
                // 24시를 넘어가지 않으면 아래에 배치
                if (newEndTime <= 24) {
                    hour = newHour;
                    minute = newMinute;
                } else {
                    // 24시를 넘어가면 위쪽에 배치 시도
                    const newStart = conflictStart - duration;
                    if (newStart >= 0) {
                        hour = Math.floor(newStart / 60);
                        minute = newStart % 60;
                    } else {
                        // 위쪽도 안되면 사용자에게 알림 후 원래 위치에 강제 배치
                        if (confirm('24시를 넘어가는 일정입니다. 그래도 배치하시겠습니까?')) {
                            // 원래 위치 유지 (hour, minute 변경하지 않음)
                        } else {
                            return; // 배치 취소
                        }
                    }
                }
            } else {
                // 위쪽에 드롭 - 기존 박스 시작시간에 종료
                const newStart = conflictStart - duration;
                if (newStart >= 0) {
                    hour = Math.floor(newStart / 60);
                    minute = newStart % 60;
                } else {
                    // 너무 위에 있으면 아래쪽 시도
                    const newHour = Math.floor(conflictEnd / 60);
                    const newMinute = conflictEnd % 60;
                    const newEndTime = newHour + Math.ceil((newMinute + duration) / 60);
                    
                    if (newEndTime <= 24) {
                        hour = newHour;
                        minute = newMinute;
                    } else {
                        // 위아래 다 안되면 사용자에게 물어봄
                        if (confirm('적절한 빈 시간을 찾을 수 없습니다. 현재 위치에 강제 배치하시겠습니까?')) {
                            // 원래 위치 유지
                        } else {
                            return; // 배치 취소
                        }
                    }
                }
            }
        } else {
            // 충돌 박스를 찾지 못하면 원래대로
            if (!isClone) {
                planboxData.push(data);
                renderPlanboxList();
            }
            return;
        }
    }
    
    // 24시를 넘어가는지 최종 체크
    const finalEndTime = hour + Math.ceil((minute + duration) / 60);
    if (finalEndTime > 24) {
        if (!confirm('이 일정은 24시를 넘어갑니다. 그래도 배치하시겠습니까?')) {
            if (!isClone) {
                planboxData.push(data);
                renderPlanboxList();
            }
            return;
        }
    }
    
    const box = document.createElement('div');
    box.className = `placed-box ${data.category}`;
    box.draggable = true;
    
    // duration already declared above, no need to redeclare
    const actualStart = extendedStart !== null ? extendedStart : timeRangeStart;
    const totalMinutes = hour * 60 + minute;
    const top = ((totalMinutes - actualStart * 60) / 60) * 60 + 48;
    const height = (duration / 60) * 60;
    
    
    box.style.top = `${top}px`;
    box.style.height = `${height}px`;
    
    const startTimeText = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
    const durationText = formatDuration(data.durationHour, data.durationMinute);
    
    // 크기별 표시 설정 - 개선된 레이아웃
    // 50분 미만은 소요시간 표시 안함, 50분 이상은 우하단에 표시
    const showDuration = duration >= 50;
    const durationBadge = showDuration ? 
        `<span style="position: absolute; bottom: 4px; right: 8px; font-size: 10px; background: rgba(255,255,255,0.9); padding: 2px 5px; border-radius: 8px; color: #666;">${durationText}</span>` : '';
    
    if (height <= 30) {
        // 30분 이하 - 시간과 제목만
        box.classList.add('compact');
        box.innerHTML = `
            <div class="placed-box-header">
                <span class="placed-box-time">${startTimeText}</span>
                <div class="placed-box-title">${data.title}</div>
            </div>
            <div class="placed-box-floating-controls">
                <button class="placed-box-control view" onclick="editPlacedBox(this.parentElement.parentElement)" title="상세정보">
                    <span class="material-icons" style="font-size: 14px;">more_horiz</span>
                </button>
            </div>
        `;
    } else if (height <= 50) {
        // 50분 이하 - 시간+제목, 메모만
        box.innerHTML = `
            <div style="position: relative; height: 100%; padding: 4px 8px;">
                <div class="placed-box-header" style="display: flex; align-items: center; gap: 6px;">
                    <span class="placed-box-time">${startTimeText}</span>
                    <div class="placed-box-title" style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${data.title}</div>
                </div>
                ${data.memo ? `<div class="placed-box-memo" style="font-size: 11px; color: #666; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin-top: 2px;">📝 ${data.memo}</div>` : ''}
            </div>
            <div class="placed-box-floating-controls">
                <button class="placed-box-control view" onclick="editPlacedBox(this.parentElement.parentElement)" title="상세정보">
                    <span class="material-icons" style="font-size: 14px;">more_horiz</span>
                </button>
            </div>
        `;
    } else if (height <= 70) {
        // 1시간 10분 - 시간+제목, 메모, 비용
        box.innerHTML = `
            <div style="position: relative; height: 100%; padding: 4px 8px;">
                <div class="placed-box-header" style="display: flex; align-items: center; gap: 6px;">
                    <span class="placed-box-time">${startTimeText}</span>
                    <div class="placed-box-title" style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${data.title}</div>
                </div>
                ${data.memo ? `<div class="placed-box-memo" style="font-size: 11px; color: #666; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin-top: 2px;">📝 ${data.memo}</div>` : ''}
                ${data.cost ? `<div class="placed-box-cost" style="font-size: 11px; color: #4CAF50; margin-top: 2px;">💰 ${data.cost}</div>` : ''}
                ${durationBadge}
            </div>
            <div class="placed-box-floating-controls">
                <button class="placed-box-control view" onclick="editPlacedBox(this.parentElement.parentElement)" title="상세정보">
                    <span class="material-icons" style="font-size: 14px;">more_horiz</span>
                </button>
            </div>
        `;
    } else if (height <= 90) {
        // 1시간 30분 - 시간+제목, 메모 1줄, 비용, 주소
        box.innerHTML = `
            <div style="position: relative; height: 100%; padding: 4px 8px;">
                <div class="placed-box-header" style="display: flex; align-items: center; gap: 6px;">
                    <span class="placed-box-time">${startTimeText}</span>
                    <div class="placed-box-title" style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${data.title}</div>
                </div>
                ${data.memo ? `<div class="placed-box-memo" style="font-size: 11px; color: #666; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin-top: 2px;">📝 ${data.memo}</div>` : ''}
                ${data.cost ? `<div class="placed-box-cost" style="font-size: 11px; color: #4CAF50; margin-top: 2px;">💰 ${data.cost}</div>` : ''}
                ${data.location ? `<div class="placed-box-location" style="font-size: 11px; color: #2196F3; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin-top: 2px;">📍 ${data.location}</div>` : ''}
                ${durationBadge}
            </div>
            <div class="placed-box-floating-controls">
                <button class="placed-box-control view" onclick="editPlacedBox(this.parentElement.parentElement)" title="상세정보">
                    <span class="material-icons" style="font-size: 14px;">more_horiz</span>
                </button>
            </div>
        `;
    } else if (height <= 110) {
        // 1시간 50분 - 시간+제목, 메모 2줄, 비용, 주소
        box.innerHTML = `
            <div style="position: relative; height: 100%; padding: 4px 8px;">
                <div class="placed-box-header" style="display: flex; align-items: center; gap: 6px;">
                    <span class="placed-box-time">${startTimeText}</span>
                    <div class="placed-box-title" style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${data.title}</div>
                </div>
                ${data.memo ? `<div class="placed-box-memo" style="font-size: 11px; color: #666; overflow: hidden; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; margin-top: 2px;">📝 ${data.memo}</div>` : ''}
                ${data.cost ? `<div class="placed-box-cost" style="font-size: 11px; color: #4CAF50; margin-top: 2px;">💰 ${data.cost}</div>` : ''}
                ${data.location ? `<div class="placed-box-location" style="font-size: 11px; color: #2196F3; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin-top: 2px;">📍 ${data.location}</div>` : ''}
                ${durationBadge}
            </div>
            <div class="placed-box-floating-controls">
                <button class="placed-box-control view" onclick="editPlacedBox(this.parentElement.parentElement)" title="상세정보">
                    <span class="material-icons" style="font-size: 14px;">more_horiz</span>
                </button>
            </div>
        `;
    } else {
        // 2시간 이상 - 시간+제목, 메모 여러줄, 가격, 여유있으면 주소
        const memoLines = Math.floor((height - 60) / 15); // 동적으로 메모 줄 수 계산
        box.innerHTML = `
            <div style="display: flex; flex-direction: column; height: 100%; overflow: hidden;">
                <div class="placed-box-header" style="display: flex; align-items: center; gap: 6px; padding: 4px 8px;">
                    <span class="placed-box-time">${startTimeText}</span>
                    <span class="placed-box-duration">${durationText}</span>
                    <div class="placed-box-title" style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${data.title}</div>
                </div>
                ${data.memo ? `<div class="placed-box-memo" style="padding: 0 8px; font-size: 11px; color: #666; flex: 1; overflow: hidden; display: -webkit-box; -webkit-line-clamp: ${memoLines}; -webkit-box-orient: vertical;">${data.memo}</div>` : '<div style="flex: 1;"></div>'}
                <div style="margin-top: auto; padding: 0 8px 4px;">
                    ${data.cost ? `<div class="placed-box-info" style="font-size: 11px; color: #333;">💰 ${data.cost}</div>` : ''}
                    ${height > 140 && data.location ? `<div class="placed-box-location" style="font-size: 11px; color: #666; margin-top: 2px;">📍 ${data.location}</div>` : ''}
                </div>
            </div>
            <div class="placed-box-floating-controls">
                <button class="placed-box-control view" onclick="editPlacedBox(this.parentElement.parentElement)" title="상세정보">
                    <span class="material-icons" style="font-size: 14px;">more_horiz</span>
                </button>
            </div>
        `;
    }
    
    box.dataset.day = day;
    box.dataset.hour = hour;
    box.dataset.minute = minute;
    box.dataset.dataId = data.id;
    box.dataset.isClone = isClone;
    box.dataset.duration = duration;
    box.dataset.title = data.title;
    box.dataset.cost = data.cost || '';
    box.dataset.memo = data.memo || '';
    box.dataset.location = data.location || '';
    // 위치 데이터를 JSON 문자열로 저장
    if (data.locationData) {
        box.dataset.locationData = JSON.stringify(data.locationData);
    }
    
    dayColumn.appendChild(box);
    
    if (!placedBoxes[day]) placedBoxes[day] = [];
    placedBoxes[day].push(box);
    
    occupyTimeSlots(day, hour, minute, duration, box);
    
    // 빈 공간 시간 표시 업데이트
    updateGapIndicators(day);
    
}

// 정확한 간격에 맞춰 들어가기 (위아래 플랜 사이에 딱 맞게)
function findAndFitGap(day, targetHour, targetMinute, data, excludeBox = null) {
    if (!occupiedSlots[day]) {
        return { 
            hour: targetHour, 
            minute: targetMinute, 
            durationHour: data.durationHour,
            durationMinute: data.durationMinute,
            success: true 
        };
    }
    
    const targetMinutes = targetHour * 60 + targetMinute;
    
    // 목표 위치 주변의 또영된 블록들 찾기
    let gapStart = 0; // 간격 시작 (기본값: 하루 시작)
    let gapEnd = 24 * 60; // 간격 끝 (기본값: 하루 끝)
    
    // 목표 위치 위쪽의 가장 가까운 점유 블록 찾기
    for (let m = targetMinutes - 10; m >= 0; m -= 10) {
        if (occupiedSlots[day][m] && occupiedSlots[day][m] !== excludeBox) {
            // 점유된 블록의 끝을 찾기 - 더 정확한 방법으로 계산
            gapStart = m + 10; // 현재 점유된 슬롯 다음 10분이 간격 시작
            break;
        }
    }
    
    // 목표 위치 아래쪽의 가장 가까운 점유 블록 찾기
    for (let m = targetMinutes; m < 24 * 60; m += 10) {
        if (occupiedSlots[day][m] && occupiedSlots[day][m] !== excludeBox) {
            gapEnd = m; // 점유된 슬롯 시작 지점이 간격 끝
            break;
        }
    }
    
    const gapDuration = gapEnd - gapStart;
    
    // 간격이 최소 10분 이상이면 들어갈 수 있음
    if (gapDuration >= 10) {
        return {
            hour: Math.floor(gapStart / 60),
            minute: gapStart % 60,
            durationHour: Math.floor(gapDuration / 60),
            durationMinute: gapDuration % 60,
            success: true
        };
    }
    
    // 적절한 간격을 찾을 수 없으면 실패
    return { 
        hour: targetHour, 
        minute: targetMinute,
        durationHour: data.durationHour,
        durationMinute: data.durationMinute,
        success: false 
    };
}

// 정확한 간격 찾기 (드롭 위치 주변의 위아래 박스 간격)
function findExactGap(day, targetHour, targetMinute) {
    if (!occupiedSlots[day]) {
        return { hasGap: false, startHour: targetHour, startMinute: targetMinute, gapDuration: 0 };
    }
    
    const targetMinutes = targetHour * 60 + targetMinute;
    let upperEndTime = 0; // 위쪽 박스의 종료 시간 (기본: 0시)
    let lowerStartTime = 24 * 60; // 아래쪽 박스의 시작 시간 (기본: 24시)
    
    // 목표 위치 위쪽에서 가장 가까운 점유 시간 찾기
    for (let m = targetMinutes - 10; m >= 0; m -= 10) {
        if (occupiedSlots[day][m]) {
            // 점유된 시간의 다음 10분이 간격 시작
            upperEndTime = m + 10;
            break;
        }
    }
    
    // 목표 위치 아래쪽에서 가장 가까운 점유 시간 찾기
    for (let m = targetMinutes; m < 24 * 60; m += 10) {
        if (occupiedSlots[day][m]) {
            // 점유된 시간이 간격 끝
            lowerStartTime = m;
            break;
        }
    }
    
    const gapDuration = lowerStartTime - upperEndTime;
    
    if (gapDuration > 0) {
        return {
            hasGap: true,
            startHour: Math.floor(upperEndTime / 60),
            startMinute: upperEndTime % 60,
            gapDuration: gapDuration
        };
    }
    
    return { hasGap: false, startHour: targetHour, startMinute: targetMinute, gapDuration: 0 };
}

// 기존 findAvailableGap 함수 (호환성을 위해 유지)
function findAvailableGap(day, targetHour, targetMinute, duration, excludeBox = null) {
    const result = findAndFitGap(day, targetHour, targetMinute, { durationHour: Math.floor(duration/60), durationMinute: duration%60 }, excludeBox);
    return { hour: result.hour, minute: result.minute, success: result.success };
}

// 간단한 간격 감지 함수 (안전하게 수정)
function findGapBetweenBoxes(day, targetMinutes) {
    if (!occupiedSlots[day]) {
        // 전체 비어있으면 그냥 반환
        return { hasGap: false, gapStart: 0, gapEnd: 24 * 60, gapDuration: 0 };
    }
    
    let gapStart = 0;  // 기본: 하루 시작
    let gapEnd = 24 * 60;  // 기본: 하루 끝
    let foundUpper = false;
    let foundLower = false;
    
    // 위쪽 박스 찾기 - 드롭 위치 바로 위의 점유된 슬롯
    for (let m = targetMinutes - 10; m >= 0; m -= 10) {
        if (occupiedSlots[day][m]) {
            // 연속된 박스의 끝 찾기
            let boxEnd = m + 10;
            while (boxEnd < 24 * 60 && occupiedSlots[day][boxEnd] === occupiedSlots[day][m]) {
                boxEnd += 10;
            }
            gapStart = boxEnd;
            foundUpper = true;
            break;
        }
    }
    
    // 아래쪽 박스 찾기 - 드롭 위치부터 시작
    for (let m = targetMinutes; m < 24 * 60; m += 10) {
        if (occupiedSlots[day][m]) {
            // 연속된 박스의 시작 찾기
            let boxStart = m;
            while (boxStart > 0 && occupiedSlots[day][boxStart - 10] === occupiedSlots[day][m]) {
                boxStart -= 10;
            }
            gapEnd = boxStart;
            foundLower = true;
            break;
        }
    }
    
    // 양쪽에 박스가 있을 때만 간격으로 처리
    if (foundUpper || foundLower) {
        const gapDuration = gapEnd - gapStart;
        return {
            hasGap: gapDuration >= 10,
            gapStart: gapStart,
            gapEnd: gapEnd,
            gapDuration: Math.max(0, gapDuration)
        };
    }
    
    // 간격이 없으면 false
    return { hasGap: false, gapStart: 0, gapEnd: 0, gapDuration: 0 };
}

// 충돌하는 박스 찾기
function findConflictingBox(day, startMinutes, duration) {
    if (!occupiedSlots[day]) return null;
    
    const endMinutes = startMinutes + duration;
    
    // 충돌하는 처음 박스 찾기
    for (let m = startMinutes; m < endMinutes; m += 10) {
        if (occupiedSlots[day][m]) {
            return occupiedSlots[day][m];
        }
    }
    
    return null;
}

// 시간 충돌 체크
function checkTimeConflict(day, hour, minute, duration, excludeBox) {
    const startMinutes = hour * 60 + minute;
    const endMinutes = startMinutes + duration;
    
    if (!occupiedSlots[day]) return false;
    
    // 전체 기간 동안 충돌 검사
    for (let m = startMinutes; m < endMinutes; m += 10) {
        if (occupiedSlots[day][m] && occupiedSlots[day][m] !== excludeBox) {
            return true;
        }
    }
    return false;
}

// 가장 가까운 빈 시간 슬롯 찾기
function findNearestEmptySlot(day, preferredHour, preferredMinute, duration) {
    const preferredMinutes = preferredHour * 60 + preferredMinute;
    const actualStart = extendedStart !== null ? extendedStart : timeRangeStart;
    const actualEnd = extendedEnd !== null ? extendedEnd : timeRangeEnd;
    
    // 선호 시간 이후 검색
    for (let minutes = preferredMinutes; minutes <= actualEnd * 60 - duration; minutes += 10) {
        const testHour = Math.floor(minutes / 60);
        const testMinute = minutes % 60;
        if (!checkTimeConflict(day, testHour, testMinute, duration, null)) {
            return { hour: testHour, minute: testMinute };
        }
    }
    
    // 선호 시간 이전 검색
    for (let minutes = preferredMinutes - 10; minutes >= actualStart * 60; minutes -= 10) {
        const testHour = Math.floor(minutes / 60);
        const testMinute = minutes % 60;
        if (!checkTimeConflict(day, testHour, testMinute, duration, null)) {
            return { hour: testHour, minute: testMinute };
        }
    }
    
    return null; // 빈 시간을 찾을 수 없음
}

// 시간 슬롯 점유
function occupyTimeSlots(day, hour, minute, duration, box) {
    if (!occupiedSlots[day]) occupiedSlots[day] = {};
    
    const startMinutes = hour * 60 + minute;
    const endMinutes = startMinutes + duration;
    
    for (let m = startMinutes; m < endMinutes; m += 10) {
        occupiedSlots[day][m] = box;
    }
}

// 점유 슬롯 해제
function releaseOccupiedSlots(box) {
    const day = parseInt(box.dataset.day);
    const hour = parseInt(box.dataset.hour);
    const minute = parseInt(box.dataset.minute);
    const duration = parseInt(box.dataset.duration);
    
    if (!occupiedSlots[day]) return;
    
    const startMinutes = hour * 60 + minute;
    const endMinutes = startMinutes + duration;
    
    for (let m = startMinutes; m < endMinutes; m += 10) {
        if (occupiedSlots[day][m] === box) {
            delete occupiedSlots[day][m];
        }
    }
}

// 배치된 박스 이동
function movePlacedBox(box, day, hour, minute) {
    const oldDay = parseInt(box.dataset.day);
    const originalDuration = parseInt(box.dataset.duration);
    
    // 기존 슬롯에서 해제
    releaseOccupiedSlots(box);
    
    // 충돌 검사 및 자동 스냅
    const targetMinutes = hour * 60 + minute;
    let finalDuration = originalDuration;
    let finalHour = hour;
    let finalMinute = minute;
    
    if (checkTimeConflict(day, hour, minute, originalDuration, box)) {
        // 충돌하는 박스 찾기
        const conflictBox = findConflictingBox(day, targetMinutes, originalDuration);
        
        if (conflictBox && conflictBox !== box) {
            const conflictStart = parseInt(conflictBox.dataset.hour) * 60 + parseInt(conflictBox.dataset.minute);
            const conflictEnd = conflictStart + parseInt(conflictBox.dataset.duration);
            const dropCenter = targetMinutes + originalDuration / 2;
            const conflictCenter = conflictStart + parseInt(conflictBox.dataset.duration) / 2;
            
            // 드롭 위치가 기존 박스의 아래쪽인지 위쪽인지 판단
            if (dropCenter > conflictCenter) {
                // 아래쪽 - 기존 박스 종료시간에 시작
                finalHour = Math.floor(conflictEnd / 60);
                finalMinute = conflictEnd % 60;
            } else {
                // 위쪽 - 기존 박스 시작시간에 종료
                const newStart = conflictStart - originalDuration;
                if (newStart >= 0) {
                    finalHour = Math.floor(newStart / 60);
                    finalMinute = newStart % 60;
                } else {
                    // 너무 위에 있으면 아래로
                    finalHour = Math.floor(conflictEnd / 60);
                    finalMinute = conflictEnd % 60;
                }
            }
        } else {
            // 충돌 박스를 찾지 못하면 원래 위치로 복구
            occupyTimeSlots(oldDay, parseInt(box.dataset.hour), parseInt(box.dataset.minute), originalDuration, box);
            return;
        }
    }
    
    // placedBoxes 배열에서 이전 위치에서 제거
    if (placedBoxes[oldDay]) {
        placedBoxes[oldDay] = placedBoxes[oldDay].filter(b => b !== box);
    }
    
    const dayColumn = document.querySelectorAll('.day-column')[day];
    const actualStart = extendedStart !== null ? extendedStart : timeRangeStart;
    const totalMinutes = finalHour * 60 + finalMinute;
    const top = ((totalMinutes - actualStart * 60) / 60) * 60 + 48;
    const height = (finalDuration / 60) * 60;
    
    // 박스 위치와 크기 업데이트
    box.style.top = `${top}px`;
    box.style.height = `${height}px`;
    box.dataset.day = day;
    box.dataset.hour = finalHour;
    box.dataset.minute = finalMinute;
    box.dataset.duration = finalDuration;
    
    updateBoxSizeClass(box, height);
    updatePlacedBoxContent(box);
    
    // 이동 후 양쪽 날짜의 gap indicator 업데이트
    if (oldDay !== day) {
        updateGapIndicators(oldDay);
    }
    updateGapIndicators(day);
    
    // DOM에 박스 추가 (같은 dayColumn이든 다른 dayColumn이든 항상 추가)
    if (dayColumn) {
        // 박스가 이미 있으면 제거 후 다시 추가
        if (box.parentNode) {
            box.parentNode.removeChild(box);
        }
        dayColumn.appendChild(box);
    }
    
    if (!placedBoxes[day]) placedBoxes[day] = [];
    placedBoxes[day].push(box);
    
    occupyTimeSlots(day, hour, minute, finalDuration, box);
    
}

// 배치된 박스 편집
function editPlacedBox(box) {
    const dataId = parseInt(box.dataset.dataId);
    const day = parseInt(box.dataset.day);
    const hour = parseInt(box.dataset.hour);
    const minute = parseInt(box.dataset.minute);
    
    let data = planboxData.find(d => d.id === dataId);
    if (!data) {
        const title = box.dataset.title || box.querySelector('.placed-box-title')?.textContent || '';
        const cost = box.dataset.cost || box.querySelector('.placed-box-info')?.textContent || '';
        const duration = parseInt(box.dataset.duration);
        
        data = {
            id: dataId,
            title: title,
            category: box.className.split(' ').find(c => ['food', 'transport', 'activity', 'sightseeing', 'shopping', 'accommodation'].includes(c)) || 'activity',
            startHour: hour,
            startMinute: minute,
            durationHour: Math.floor(duration / 60),
            durationMinute: duration % 60,
            cost: cost,
            memo: box.dataset.memo || '',
            location: box.dataset.location || '',
            locationData: box.dataset.locationData ? JSON.parse(box.dataset.locationData) : null
        };
    }
    
    editingPlacedBox = box;
    editingBoxId = dataId;
    
    // 시간 셀렉트 박스가 비어있으면 초기화
    const startHourSelect = document.getElementById('startHour');
    if (!startHourSelect.options.length) {
        initializeTimeSelects();
    }
    
    // 모달 제목 설정
    document.getElementById('modalTitleDisplay').textContent = data.title;
    document.getElementById('modalTitleEdit').value = data.title;
    document.getElementById('boxTitle').value = data.title;
    
    // 폼 필드 설정
    document.getElementById('startHour').value = hour;
    document.getElementById('startMinute').value = minute;
    document.getElementById('durationHour').value = data.durationHour;
    document.getElementById('durationMinute').value = data.durationMinute;
    document.getElementById('boxCategory').value = data.category;
    document.getElementById('boxCost').value = data.cost || '';
    document.getElementById('boxMemo').value = data.memo || '';
    
    // 위치 정보 복원 (있다면)
    const locationInput = document.getElementById('locationInput');
    if (locationInput) {
        locationInput.value = data.location || '';
        selectedLocationData = data.locationData || null;
        console.log('위치 정보 복원:', selectedLocationData);
    }
    
    // 위치 자동완성 초기화 (편집 모달이 열릴 때마다)
    setTimeout(() => {
        initLocationAutocomplete();
        
        // Kakao API가 로드되지 않았으면 로드
        if (typeof kakao === 'undefined' && !kakaoMapLoading) {
            console.log('편집 모달에서 Kakao API 로드 시작');
            loadKakaoMapAPI(() => {
                console.log('Kakao API 로드 완료 (편집 모달)');
            });
        }
    }, 100);
    
    // 수정 모드일 때 삭제 버튼 표시
    document.getElementById('deleteBtn').style.display = 'flex';
    
    updateEndTimeDisplay();
    document.getElementById('planboxModal').classList.add('show');
}

// 배치된 박스 삭제
function removePlacedBox(box) {
    const day = parseInt(box.dataset.day);
    
    showConfirm('이 일정을 삭제하시겠습니까?', () => {
        releaseOccupiedSlots(box);
        
        if (placedBoxes[day]) {
            placedBoxes[day] = placedBoxes[day].filter(b => b !== box);
        }
        
        if (!box.dataset.isClone || box.dataset.isClone === 'false') {
            const dataId = parseInt(box.dataset.dataId);
            const originalData = planboxData.find(d => d.id === dataId);
            if (!originalData) {
                const title = box.dataset.title || box.querySelector('.placed-box-title')?.textContent || '';
                const cost = box.dataset.cost || box.querySelector('.placed-box-info')?.textContent || '';
                const duration = parseInt(box.dataset.duration);
                
                planboxData.push({
                    id: dataId,
                    title: title,
                    category: box.className.split(' ').find(c => ['food', 'transport', 'activity', 'accommodation'].includes(c)) || 'activity',
                    startHour: parseInt(box.dataset.hour),
                    startMinute: parseInt(box.dataset.minute),
                    durationHour: Math.floor(duration / 60),
                    durationMinute: duration % 60,
                    cost: cost,
                    memo: box.dataset.memo || '',
                    location: box.dataset.location || ''
                });
                
                renderPlanboxList();
            }
        }
        
        box.remove();
        updateGapIndicators(day);
        
    });
}

// 타임라인 업데이트
function updateTimeline() {
    const startDate = new Date(document.getElementById('startDate').value);
    const endDate = new Date(document.getElementById('endDate').value);
    const days = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
    
    if (days > 0 && days <= 14) {
        totalDays = days;
        createTimeLabels();
        createDayColumns();
    } else {
        alert('여행 기간은 1일에서 14일 사이로 설정해주세요');
    }
}

// 제목 인라인 편집 시작
function startTitleEdit() {
    const display = document.getElementById('modalTitleDisplay');
    const edit = document.getElementById('modalTitleEdit');
    
    edit.value = display.textContent;
    display.style.display = 'none';
    edit.style.display = 'block';
    edit.focus();
    edit.select();
}

// 제목 인라인 편집 종료
function finishTitleEdit() {
    const display = document.getElementById('modalTitleDisplay');
    const edit = document.getElementById('modalTitleEdit');
    
    if (edit.value.trim()) {
        display.textContent = edit.value.trim();
        document.getElementById('boxTitle').value = edit.value.trim();
    }
    
    edit.style.display = 'none';
    display.style.display = 'block';
}

// 제목 편집 토글
function toggleTitleEdit() {
    const display = document.getElementById('modalTitleDisplay');
    const edit = document.getElementById('modalTitleEdit');
    
    if (edit.style.display === 'none' || !edit.style.display) {
        startTitleEdit();
    } else {
        finishTitleEdit();
    }
}

// 제목 편집 키보드 이벤트 처리
function handleTitleEditKey(event) {
    if (event.key === 'Enter') {
        event.preventDefault();
        finishTitleEdit();
    } else if (event.key === 'Escape') {
        event.preventDefault();
        const display = document.getElementById('modalTitleDisplay');
        const edit = document.getElementById('modalTitleEdit');
        edit.value = display.textContent; // 원래 값으로 복원
        finishTitleEdit();
    }
}

// 지도 모달 열기
function openMapModal() {
    // 지도 모달이 없으면 생성
    let mapModal = document.getElementById('mapModal');
    if (!mapModal) {
        createMapModal();
        mapModal = document.getElementById('mapModal');
    }
    
    // 모달 표시
    mapModal.classList.add('show');
    
    // 지도 초기화 (약간의 지연으로 모달이 표시된 후 초기화)
    setTimeout(() => {
        initializeKakaoMap();
    }, 100);
    // - 검색 기능
    // - 선택한 위치를 locationInput에 반영
}

// 모달 표시
function showAddModal(presetHour, presetMinute) {
    editingBoxId = null;
    editingPlacedBox = null;
    
    // 시간 셀렉트 박스가 비어있으면 초기화
    const startHourSelect = document.getElementById('startHour');
    if (!startHourSelect.options.length) {
        initializeTimeSelects();
    }
    
    // 위치 자동완성 초기화 (모달이 열릴 때마다)
    setTimeout(() => {
        initLocationAutocomplete();
        
        // Kakao API가 로드되지 않았으면 로드
        if (typeof kakao === 'undefined' && !kakaoMapLoading) {
            console.log('새 모달에서 Kakao API 로드 시작');
            loadKakaoMapAPI(() => {
                console.log('Kakao API 로드 완료 (새 모달)');
            });
        }
    }, 100);
    
    // 새로운 모달 UI 설정
    document.getElementById('modalTitleDisplay').textContent = '새 플랜';
    document.getElementById('modalTitleEdit').value = '새 플랜';
    document.getElementById('boxTitle').value = '새 플랜';
    
    // 제목 편집 모드 초기화
    document.getElementById('modalTitleDisplay').style.display = 'block';
    document.getElementById('modalTitleEdit').style.display = 'none';
    
    // 새 플랜박스 생성 시 삭제 버튼 숨기기
    document.getElementById('deleteBtn').style.display = 'none';
    
    clearModalForm();
    
    // 일반 카테고리 모드로 설정
    showRegularCategoryUI();
    
    // 시간대가 지정된 경우에만 시간 설정 (타임라인에서 직접 생성하는 경우)
    if (presetHour !== undefined && presetMinute !== undefined) {
        document.getElementById('startHour').value = presetHour;
        document.getElementById('startMinute').value = presetMinute;
    } else {
        // 시간 미설정 상태로 유지
        document.getElementById('startHour').value = '';
        document.getElementById('startMinute').value = '';
    }
    
    updateEndTimeDisplay();
    document.getElementById('planboxModal').classList.add('show');
}

// 플랜박스 수정
function editPlanbox(id) {
    const box = planboxData.find(b => b.id === id);
    if (!box) return;
    
    editingBoxId = id;
    editingPlacedBox = null;
    
    // 새로운 모달 UI에 데이터 설정
    document.getElementById('modalTitleDisplay').textContent = box.title;
    document.getElementById('modalTitleEdit').value = box.title;
    document.getElementById('boxTitle').value = box.title;
    document.getElementById('startHour').value = box.startHour;
    document.getElementById('startMinute').value = box.startMinute;
    document.getElementById('durationHour').value = box.durationHour;
    document.getElementById('durationMinute').value = box.durationMinute;
    
    // 카테고리에 따른 UI 전환
    if (box.category === 'transport') {
        showTransportCategoryUI();
        document.getElementById('transportMethod').value = box.transportMethod || 'TRANSIT';
    } else {
        showRegularCategoryUI();
        document.getElementById('boxCategory').value = box.category;
    }
    
    document.getElementById('boxCost').value = box.cost || '';
    document.getElementById('boxMemo').value = box.memo || '';
    
    // 위치 정보 복원
    const locationInput = document.getElementById('locationInput');
    if (locationInput) {
        locationInput.value = box.location || '';
        selectedLocationData = box.locationData || null;
    }
    
    // 위치 자동완성 초기화 (사이드바 박스 편집 시에도)
    setTimeout(() => {
        initLocationAutocomplete();
        
        // Kakao API가 로드되지 않았으면 로드
        if (typeof kakao === 'undefined' && !kakaoMapLoading) {
            console.log('사이드바 박스 편집에서 Kakao API 로드 시작');
            loadKakaoMapAPI(() => {
                console.log('Kakao API 로드 완료 (사이드바 박스)');
            });
        }
    }, 100);
    
    // 수정 모드일 때 삭제 버튼 표시
    document.getElementById('deleteBtn').style.display = 'block';
    
    updateEndTimeDisplay();
    document.getElementById('planboxModal').classList.add('show');
}

// 모달에서 삭제 처리
function deletePlanboxFromModal() {
    if (editingPlacedBox) {
        // 배치된 박스 삭제
        const boxToDelete = editingPlacedBox;
        hideModal(); // 먼저 모달을 닫고
        
        showConfirm('이 일정을 삭제하시겠습니까?', () => {
            // 기존 removePlacedBox 함수 내용과 유사하게 처리
            const day = parseInt(boxToDelete.dataset.day);
            releaseOccupiedSlots(boxToDelete);
            
            if (placedBoxes[day]) {
                placedBoxes[day] = placedBoxes[day].filter(b => b !== boxToDelete);
            }
            
            if (!boxToDelete.dataset.isClone || boxToDelete.dataset.isClone === 'false') {
                const dataId = parseInt(boxToDelete.dataset.dataId);
                const originalData = planboxData.find(d => d.id === dataId);
                if (!originalData) {
                    const title = boxToDelete.dataset.title || boxToDelete.querySelector('.placed-box-title')?.textContent || '';
                    const cost = boxToDelete.dataset.cost || boxToDelete.querySelector('.placed-box-info')?.textContent || '';
                    const duration = parseInt(boxToDelete.dataset.duration);
                    
                    planboxData.push({
                        id: dataId,
                        title: title,
                        category: boxToDelete.className.split(' ').find(c => ['food', 'transport', 'activity', 'accommodation'].includes(c)) || 'activity',
                        startHour: parseInt(boxToDelete.dataset.hour),
                        startMinute: parseInt(boxToDelete.dataset.minute),
                        durationHour: Math.floor(duration / 60),
                        durationMinute: duration % 60,
                        cost: cost,
                        memo: ''
                    });
                }
                renderPlanboxList();
            }
            
            boxToDelete.remove();
            updateGapIndicators(day);
        });
    } else if (editingBoxId) {
        // 사이드바 플랜박스 삭제
        hideModal(); // 먼저 모달을 닫고
        
        showConfirm('이 플랜박스를 삭제하시겠습니까?', () => {
            planboxData = planboxData.filter(box => box.id !== editingBoxId);
            if (cloneSourceId === editingBoxId) {
                cloneSourceId = null;
                isCloneMode = false;
                document.querySelectorAll('.planbox-item').forEach(item => {
                    item.classList.remove('clone-source');
                });
            }
            renderPlanboxList();
        });
    }
}

// 플랜박스 삭제
function deletePlanbox(id) {
    showConfirm('이 플랜박스를 삭제하시겠습니까?', () => {
        planboxData = planboxData.filter(box => box.id !== id);
        if (cloneSourceId === id) {
            cloneSourceId = null;
            isCloneMode = false;
        }
        
        markAsChanged(); // 자동 저장 트리거
        checkExtendedTimeRange();
        createTimeLabels();
        createDayColumns();
        renderPlanboxList();
    });
}

// 플랜박스 저장
function savePlanbox() {
    const title = document.getElementById('boxTitle').value || document.getElementById('modalTitleDisplay').textContent;
    if (!title) {
        alert('제목을 입력해주세요');
        return;
    }
    
    // 시간과 분 값을 안전하게 파싱
    const durationHourValue = document.getElementById('durationHour').value;
    const durationMinuteValue = document.getElementById('durationMinute').value;
    
    // 정확한 값 파싱 (빈 문자열이나 NaN 처리)
    const parsedDurationHour = (durationHourValue === '' || isNaN(parseInt(durationHourValue))) ? 0 : parseInt(durationHourValue);
    const parsedDurationMinute = (durationMinuteValue === '' || isNaN(parseInt(durationMinuteValue))) ? 0 : parseInt(durationMinuteValue);
    
    // 위치 정보 디버깅
    console.log('저장 시점 위치 정보:', {
        locationInput: document.getElementById('locationInput').value,
        selectedLocationData: selectedLocationData
    });
    
    // 편집 모드인지 확인 (타임라인에 배치된 박스 편집 중)
    const isPlacedBoxEdit = editingPlacedBox !== null;
    
    const boxData = {
        id: editingBoxId || Date.now(),
        title: title,
        startHour: isPlacedBoxEdit ? (document.getElementById('startHour').value === '' ? 9 : parseInt(document.getElementById('startHour').value)) : null,
        startMinute: isPlacedBoxEdit ? (parseInt(document.getElementById('startMinute').value) || 0) : null,
        durationHour: parsedDurationHour || 1,  // 기본값 1시간
        durationMinute: parsedDurationMinute || 0,
        category: document.getElementById('boxCategory').value || 'transport',
        transportMethod: document.getElementById('transportMethod')?.value || selectedTransportMethod,
        cost: document.getElementById('boxCost').value || '',
        memo: document.getElementById('boxMemo').value || '',
        location: document.getElementById('locationInput').value || '',
        locationData: selectedLocationData || null,  // 위도/경도 등 상세 정보
        hasTimeSet: isPlacedBoxEdit  // 타임라인에 배치된 경우만 시간 설정됨
    };
    
    console.log('생성된 boxData:', boxData);
    
    // 전체 duration 계산 (분 단위)
    let totalDuration = boxData.durationHour * 60 + boxData.durationMinute;
    
    // 최소 30분 보장
    if (totalDuration < 30) {
        totalDuration = 30;
        boxData.durationHour = 0;
        boxData.durationMinute = 30;
    } else {
        // 정확한 시간과 분으로 재계산
        boxData.durationHour = Math.floor(totalDuration / 60);
        boxData.durationMinute = totalDuration % 60;
    }
    
    if (editingPlacedBox) {
        const day = parseInt(editingPlacedBox.dataset.day);
        const newDuration = totalDuration;  // 이미 계산된 totalDuration 사용
        
        // 편집 중인 박스가 타임라인에 있는 경우만 충돌 검사
        if (checkTimeConflict(day, boxData.startHour, boxData.startMinute, newDuration, editingPlacedBox)) {
            return;
        }
        
        releaseOccupiedSlots(editingPlacedBox);
        
        const actualStart = extendedStart !== null ? extendedStart : timeRangeStart;
        const totalMinutes = boxData.startHour * 60 + boxData.startMinute;
        const top = ((totalMinutes - actualStart * 60) / 60) * 60 + 48;
        const height = (newDuration / 60) * 60;
        
        editingPlacedBox.style.top = `${top}px`;
        editingPlacedBox.style.height = `${height}px`;
        editingPlacedBox.className = `placed-box ${boxData.category}`;
        editingPlacedBox.dataset.hour = boxData.startHour;
        editingPlacedBox.dataset.minute = boxData.startMinute;
        editingPlacedBox.dataset.duration = newDuration;
        editingPlacedBox.dataset.title = boxData.title;
        editingPlacedBox.dataset.cost = boxData.cost || '';
        editingPlacedBox.dataset.memo = boxData.memo || '';
        editingPlacedBox.dataset.location = boxData.location || '';
        if (boxData.locationData) {
            editingPlacedBox.dataset.locationData = JSON.stringify(boxData.locationData);
        }
        
        updateBoxSizeClass(editingPlacedBox, height);
        updatePlacedBoxContent(editingPlacedBox);
        
        occupyTimeSlots(day, boxData.startHour, boxData.startMinute, newDuration, editingPlacedBox);
        
        // planboxData도 업데이트 (중요!)
        const dataId = parseInt(editingPlacedBox.dataset.dataId);
        const existingIndex = planboxData.findIndex(p => p.id === dataId);
        if (existingIndex !== -1) {
            planboxData[existingIndex] = boxData;
        }
        
    } else if (editingBoxId) {
        const index = planboxData.findIndex(box => box.id === editingBoxId);
        if (index !== -1) {
            planboxData[index] = boxData;
        }
    } else {
        planboxData.push(boxData);
    }
    
    checkExtendedTimeRange();
    if (extendedStart !== null || extendedEnd !== null) {
        createTimeLabels();
        createDayColumns();
    }
    
    renderPlanboxList();
    hideModal();
}

// 모달 폼 초기화
function clearModalForm() {
    document.getElementById('boxTitle').value = '';
    // startHour와 startMinute는 showAddModal에서 설정하므로 여기서는 건드리지 않음
    // document.getElementById('startHour').value는 변경하지 않음
    // document.getElementById('startMinute').value는 변경하지 않음
    document.getElementById('durationHour').value = 1;  // 기본값을 1시간으로 변경
    document.getElementById('durationMinute').value = 0;  // 기본값을 0분으로 변경
    document.getElementById('boxCategory').value = 'activity';
    document.getElementById('boxCost').value = '';
    document.getElementById('boxMemo').value = '';
    const locationInput = document.getElementById('locationInput');
    if (locationInput) locationInput.value = '';
    // 위치 데이터 초기화
    selectedLocationData = null;
}

// 모달 숨기기
function hideModal() {
    document.getElementById('planboxModal').classList.remove('show');
    editingPlacedBox = null;
    // 위치 데이터 초기화
    selectedLocationData = null;
}

// 확인 모달 표시
function showConfirm(message, callback) {
    document.getElementById('confirmMessage').textContent = message;
    document.getElementById('confirmModal').classList.add('show');
    
    document.getElementById('confirmBtn').onclick = () => {
        callback();
        hideConfirm();
    };
}

// 확인 모달 숨기기
function hideConfirm() {
    document.getElementById('confirmModal').classList.remove('show');
}

// 인쇄
function printSchedule() {
    setViewMode('print');
    setTimeout(() => {
        window.print();
        setTimeout(() => {
            setViewMode('edit');
        }, 100);
    }, 300);
}

// 모달 외부 클릭
document.getElementById('planboxModal').addEventListener('click', (e) => {
    if (e.target === e.currentTarget) {
        hideModal();
    }
});

document.getElementById('confirmModal').addEventListener('click', (e) => {
    if (e.target === e.currentTarget) {
        hideConfirm();
    }
});

// 카카오맵 초기화
function initKakaoMap(container) {
    if (tripRegion === 'domestic' && window.kakao && window.kakao.maps) {
        const options = {
            center: new kakao.maps.LatLng(37.566535, 126.9779692), // 서울 중심
            level: 5
        };
        
        const map = new kakao.maps.Map(container, options);
        
        // 지도 클릭 이벤트
        kakao.maps.event.addListener(map, 'click', function(mouseEvent) {
            const latlng = mouseEvent.latLng;
            
            // 마커 생성
            const marker = new kakao.maps.Marker({
                position: latlng,
                map: map
            });
            
            // 주소 검색
            const geocoder = new kakao.maps.services.Geocoder();
            geocoder.coord2Address(latlng.getLng(), latlng.getLat(), function(result, status) {
                if (status === kakao.maps.services.Status.OK) {
                    const address = result[0].address.address_name;
                    document.getElementById('locationSearch').value = address;
                }
            });
        });
        
        return map;
    } else {
        // 해외 여행인 경우 구글맵 (추후 구현)
        container.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #999;">
                <div style="text-align: center;">
                    <span class="material-icons" style="font-size: 48px; color: #ddd;">map</span>
                    <p style="margin-top: 8px;">구글맵 지원 예정</p>
                </div>
            </div>
        `;
    }
}

// 초기 설정 관련 함수
function showSetupModal() {
    const modal = document.createElement('div');
    modal.className = 'modal show';
    modal.id = 'setupModal';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 500px;">
            <div style="padding: 32px;">
                <h2 style="font-size: 24px; color: #1976D2; margin-bottom: 8px; font-weight: 600;">
                    <span class="material-icons" style="vertical-align: middle; margin-right: 8px;">flight_takeoff</span>
                    여행 계획 시작하기
                </h2>
                <p style="color: #666; margin-bottom: 24px;">여행의 기본 정보를 입력해주세요</p>
                
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 4px;">
                        <span class="material-icons-outlined" style="font-size: 18px;">edit</span>
                        여행 제목
                    </label>
                    <input type="text" id="setupTripTitle" placeholder="예: 도쿄 3박 4일 여행" style="width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 15px;">
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 20px;">
                    <div class="form-group">
                        <label style="display: flex; align-items: center; gap: 4px;">
                            <span class="material-icons-outlined" style="font-size: 18px;">event</span>
                            시작일
                        </label>
                        <input type="date" id="setupStartDate" style="width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 15px;">
                    </div>
                    <div class="form-group">
                        <label style="display: flex; align-items: center; gap: 4px;">
                            <span class="material-icons-outlined" style="font-size: 18px;">event</span>
                            종료일
                        </label>
                        <input type="date" id="setupEndDate" style="width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 15px;">
                    </div>
                </div>
                
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 4px; margin-bottom: 12px;">
                        <span class="material-icons-outlined" style="font-size: 18px;">public</span>
                        여행 지역
                    </label>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                        <button onclick="setTripRegion('domestic')" id="domesticBtn" style="padding: 16px; border: 2px solid #e0e0e0; border-radius: 12px; background: white; cursor: pointer; transition: all 0.2s; display: flex; flex-direction: column; align-items: center; gap: 8px;">
                            <span class="material-icons" style="font-size: 32px; color: #4CAF50;">location_on</span>
                            <span style="font-size: 16px; font-weight: 500;">국내</span>
                            <span style="font-size: 12px; color: #666;">카카오맵 지원</span>
                        </button>
                        <button onclick="setTripRegion('overseas')" id="overseasBtn" style="padding: 16px; border: 2px solid #e0e0e0; border-radius: 12px; background: white; cursor: pointer; transition: all 0.2s; display: flex; flex-direction: column; align-items: center; gap: 8px;">
                            <span class="material-icons" style="font-size: 32px; color: #2196F3;">flight</span>
                            <span style="font-size: 16px; font-weight: 500;">해외</span>
                            <span style="font-size: 12px; color: #666;">구글맵 지원</span>
                        </button>
                    </div>
                </div>
                
                <button onclick="completeSetup()" style="width: 100%; padding: 14px; background: #1976D2; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 500; cursor: pointer; margin-top: 24px; transition: all 0.15s;">
                    시작하기
                </button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
    
    // 오늘 날짜 기본값 설정
    const today = new Date().toISOString().split('T')[0];
    const endDate = new Date();
    endDate.setDate(endDate.getDate() + 6);
    
    document.getElementById('setupStartDate').value = today;
    document.getElementById('setupEndDate').value = endDate.toISOString().split('T')[0];
}

// 여행 지역 설정
function setTripRegion(region) {
    tripRegion = region;
    
    // 버튼 활성화 표시
    if (region === 'domestic') {
        document.getElementById('domesticBtn').style.borderColor = '#4CAF50';
        document.getElementById('domesticBtn').style.background = '#e8f5e9';
        document.getElementById('overseasBtn').style.borderColor = '#e0e0e0';
        document.getElementById('overseasBtn').style.background = 'white';
    } else {
        document.getElementById('overseasBtn').style.borderColor = '#2196F3';
        document.getElementById('overseasBtn').style.background = '#e3f2fd';
        document.getElementById('domesticBtn').style.borderColor = '#e0e0e0';
        document.getElementById('domesticBtn').style.background = 'white';
    }
}

// 초기 설정 완료
function completeSetup() {
    const title = document.getElementById('setupTripTitle').value;
    const startDate = document.getElementById('setupStartDate').value;
    const endDate = document.getElementById('setupEndDate').value;
    
    if (!title || !startDate || !endDate) {
        alert('모든 정보를 입력해주세요');
        return;
    }
    
    // 메인 헤더에 정보 설정
    document.getElementById('tripTitle').value = title;
    document.getElementById('startDate').value = startDate;
    document.getElementById('endDate').value = endDate;
    
    // 설정 완료 표시
    localStorage.setItem('tripSetupComplete', 'true');
    localStorage.setItem('tripRegion', tripRegion);
    
    // 모달 닫기
    const modal = document.getElementById('setupModal');
    if (modal) {
        modal.remove();
    }
    
    // 타임라인 초기화
    updateTimeline();
    // initTimeOptions가 존재하는지 확인
    if (typeof initTimeOptions === 'function') {
        initTimeOptions();
    }
    renderPlanboxList();
    // 에러가 발생해도 계속 진행하도록 try-catch 추가
    try {
        console.log('setupDragEvents 호출 전');
        setupDragEvents();
        console.log('setupDragEvents 호출 후');
    } catch (e) {
        console.error('setupDragEvents 에러:', e);
    }
    
    try {
        console.log('setupResizeEvents 호출 전');
        setupResizeEvents();
        console.log('setupResizeEvents 호출 후');
    } catch (e) {
        console.error('setupResizeEvents 에러:', e);
    }
    
    enableAutoSave();
}

// 키보드 단축키
// 카테고리 빠른 생성 함수 추가
// 이동박스 전용 생성 함수 - 시간 미설정 박스 생성
function createTransportBox() {
    console.log('이동박스 생성');
    
    // 새 이동박스 데이터 생성 (시간 미설정 상태)
    const transportData = {
        id: Date.now(),
        title: '이동',
        category: 'transport',
        startHour: null,  // null은 시간 미설정을 명확히 나타냄
        startMinute: null,
        durationHour: 0,
        durationMinute: 30,  // 기본 30분
        cost: '',
        memo: '',
        transportMethod: 'TRANSIT',  // 기본값: 대중교통
        hasTimeSet: false  // 시간 설정 여부 플래그
    };
    
    // 플랜박스 리스트에 추가
    planboxData.push(transportData);
    
    // 필터 상태와 관계없이 렌더링
    if (currentCategoryFilter !== 'all' && currentCategoryFilter !== 'transport') {
        currentCategoryFilter = 'all';
        document.getElementById('categoryFilter').value = 'all';
    }
    
    renderPlanboxList();
    markAsChanged(); // 자동 저장 트리거
    
    // 생성된 박스가 보이도록 스크롤
    scrollToBottom();
    
    console.log('이동 박스가 생성되었습니다. 타임라인으로 드래그하세요.');
}

// 일반 카테고리 생성 함수 (이동 제외) - 원래대로 시간 미설정 박스 생성
function createQuickBox(category) {
    // 카테고리별 기본 설정
    const categoryDefaults = {
        'activity': { label: '활동', duration: 60, color: '#579AFF' },
        'sightseeing': { label: '관광', duration: 60, color: '#A374F9' },
        'food': { label: '식사', duration: 60, color: '#FF9500' },
        'shopping': { label: '쇼핑', duration: 60, color: '#FF6B9D' },
        'accommodation': { label: '숙박', duration: 60, color: '#784AF4' }
    };
    
    const defaults = categoryDefaults[category] || { label: '일정', duration: 60, color: '#f5f5f5' };
    
    // 새 플랜박스 데이터 생성 (시간 미설정 상태)
    const quickData = {
        id: Date.now(),
        title: defaults.label,  // 카테고리 이름을 기본 제목으로 설정
        category: category,
        startHour: null,  // null은 시간 미설정을 명확히 나타냄
        startMinute: null,
        durationHour: Math.floor(defaults.duration / 60),
        durationMinute: defaults.duration % 60,
        cost: '',
        memo: '',
        hasTimeSet: false  // 시간 설정 여부 플래그
    };
    
    // 플랜박스 리스트에 추가
    planboxData.push(quickData);
    
    // 필터 상태와 관계없이 렌더링 (생성된 박스가 필터에 맞지 않아도 보이도록)
    // 만약 현재 필터가 해당 카테고리가 아니면 전체 보기로 변경
    if (currentCategoryFilter !== 'all' && currentCategoryFilter !== category) {
        // 또는 전체 보기로 변경
        currentCategoryFilter = 'all';
        document.getElementById('categoryFilter').value = 'all';
    }
    
    renderPlanboxList();
    markAsChanged(); // 자동 저장 트리거
    
    // 생성된 박스가 보이도록 스크롤
    scrollToBottom();
    
    // 피드백 메시지
    console.log(`${defaults.label} 박스가 생성되었습니다. 타임라인으로 드래그하세요.`);
}

document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        if (document.getElementById('confirmModal').classList.contains('show')) {
            hideConfirm();
        } else if (document.getElementById('planboxModal').classList.contains('show')) {
            hideModal();
        }
    }
});

// 초기화 함수
function clearAndRestart() {
    if (confirm('모든 데이터를 삭제하고 처음부터 시작하시겠습니까?')) {
        localStorage.clear();
        location.reload();
    }
}

// 테스트 함수
function testResize() {
    console.log('테스트 버튼 클릭됨');
    const boxes = document.querySelectorAll('.placed-box');
    console.log('박스 개수:', boxes.length);
    if (boxes.length > 0) {
        boxes[0].style.backgroundColor = 'lime';
        alert('첫 번째 박스를 라임색으로 변경했습니다. \n이제 박스 하단을 드래그해보세요.');
    } else {
        alert('박스가 없습니다. 먼저 플랜박스를 타임라인에 배치해주세요.');
    }
    
    // 디버깅 완료
    console.log('리사이즈 테스트 완료');
}

// 초기화 실행
console.log('init 함수 호출 전');
init();
console.log('init 함수 호출 후');

// 모든 이벤트가 확실히 설정되도록 강제 설정
setTimeout(() => {
    console.log('=== 이벤트 강제 재설정 ===');
    
    // 드래그 이벤트 재설정
    try {
        setupDragEvents();
        console.log('드래그 이벤트 재설정 완료');
    } catch (e) {
        console.error('드래그 이벤트 에러:', e);
    }
    
    // 리사이즈 이벤트 재설정
    try {
        setupResizeEvents();
        console.log('리사이즈 이벤트 재설정 완료');
    } catch (e) {
        console.error('리사이즈 이벤트 에러:', e);
    }
    
    // 기존 박스들에 draggable 속성 확실히 추가
    const allPlacedBoxes = document.querySelectorAll('.placed-box');
    console.log(`발견된 placed-box 개수: ${allPlacedBoxes.length}`);
    
    allPlacedBoxes.forEach((box, index) => {
        box.draggable = true;
        box.setAttribute('draggable', 'true');  // 속성도 명시적으로 설정
        console.log(`박스 ${index + 1} draggable 설정:`, box.draggable, box);
    });
    
    console.log('모든 placed-box에 draggable 속성 추가 완료');
}, 1500);

// 위치 자동완성 초기화
let searchTimeout = null;
let selectedLocationData = null;

function initLocationAutocomplete() {
    console.log('=== initLocationAutocomplete 호출됨 ===');
    const locationInput = document.getElementById('locationInput');
    const locationDropdown = document.getElementById('locationDropdown');
    
    if (!locationInput) {
        console.log('locationInput 요소를 찾을 수 없습니다');
        return;
    }
    
    console.log('locationInput 찾음:', locationInput);
    console.log('현재 Kakao API 상태:', typeof kakao !== 'undefined' ? '로드됨' : '로드 안됨');
    
    // 기존 이벤트 리스너 제거 (중복 방지)
    const newInput = locationInput.cloneNode(true);
    locationInput.parentNode.replaceChild(newInput, locationInput);
    const finalInput = document.getElementById('locationInput');  // 새로 교체된 요소 가져오기
    
    console.log('이벤트 리스너 재설정 완료');
    
    // 입력 이벤트
    finalInput.addEventListener('input', function() {
        console.log('입력 이벤트 발생:', this.value);
        const keyword = this.value.trim();
        
        if (keyword.length < 2) {
            hideLocationDropdown();
            return;
        }
        
        // 디바운싱
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
            searchLocations(keyword);
        }, 300);
    });
    
    // 포커스 아웃 시 드롭다운 숨기기 (충분한 지연)
    finalInput.addEventListener('blur', function() {
        setTimeout(() => {
            hideLocationDropdown();
        }, 300);  // 200ms -> 300ms로 증가하여 클릭 이벤트가 먼저 실행되도록 함
    });
    
    // 키보드 네비게이션
    finalInput.addEventListener('keydown', function(e) {
        const items = locationDropdown.querySelectorAll('.location-item');
        const selectedItem = locationDropdown.querySelector('.location-item.selected');
        let selectedIndex = Array.from(items).indexOf(selectedItem);
        
        if (e.key === 'ArrowDown') {
            e.preventDefault();
            if (selectedIndex < items.length - 1) {
                selectedIndex++;
                selectLocationItem(items[selectedIndex]);
            }
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            if (selectedIndex > 0) {
                selectedIndex--;
                selectLocationItem(items[selectedIndex]);
            }
        } else if (e.key === 'Enter') {
            e.preventDefault();
            if (selectedItem) {
                const data = JSON.parse(selectedItem.dataset.location);
                setLocation(data);
            }
        } else if (e.key === 'Escape') {
            hideLocationDropdown();
        }
    });
}

// 장소 검색
function searchLocations(keyword) {
    console.log('searchLocations 호출:', keyword);
    
    // 로컬 파일 실행 체크
    if (window.location.protocol === 'file:') {
        const dropdown = document.getElementById('locationDropdown');
        dropdown.innerHTML = '<div class="location-item" style="text-align: center; color: #ff6b6b; padding: 15px;">⚠️ 로컬 서버를 실행해주세요<br><small>start_powershell_server.bat 실행 후<br>http://localhost:3000 접속</small></div>';
        dropdown.classList.add('show');
        return;
    }
    
    // 카카오맵 API 로드 확인
    if (typeof kakao === 'undefined' || !kakao.maps || !kakao.maps.services) {
        console.log('Kakao API가 로드되지 않음, 로딩 시도...');
        // API가 로드되지 않은 경우 로드 시도
        loadKakaoMapAPI(() => {
            performLocationSearch(keyword);
        });
    } else {
        console.log('Kakao API 사용 가능, 검색 실행');
        performLocationSearch(keyword);
    }
}

// 실제 검색 수행
function performLocationSearch(keyword) {
    console.log('performLocationSearch 호출:', keyword);
    const ps = new kakao.maps.services.Places();
    
    ps.keywordSearch(keyword, function(data, status) {
        console.log('검색 결과:', status, data);
        if (status === kakao.maps.services.Status.OK) {
            showLocationDropdown(data);
        } else if (status === kakao.maps.services.Status.ZERO_RESULT) {
            showLocationDropdown([]);
        } else {
            console.log('검색 오류:', status);
        }
    }, {
        size: 10  // 결과 개수 제한
    });
}

// 드롭다운 표시
function showLocationDropdown(places) {
    const dropdown = document.getElementById('locationDropdown');
    
    if (!places || places.length === 0) {
        dropdown.innerHTML = '<div class="location-item" style="text-align: center; color: #868e96;">검색 결과가 없습니다</div>';
        dropdown.classList.add('show');
        return;
    }
    
    dropdown.innerHTML = places.map((place, index) => `
        <div class="location-item" data-location='${JSON.stringify(place).replace(/'/g, '&apos;')}' onmousedown="event.preventDefault();">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div style="flex: 1;">
                    <div class="location-item-name">${place.place_name}</div>
                    <div class="location-item-address">${place.road_address_name || place.address_name}</div>
                    ${place.category_group_name ? `<span class="location-item-category">${place.category_group_name}</span>` : ''}
                </div>
                <div style="display: flex; gap: 5px;">
                    <button class="location-select-btn" style="padding: 2px 8px; font-size: 11px; border: 1px solid #2196F3; background: white; color: #2196F3; border-radius: 3px; cursor: pointer;" 
                            onmousedown="event.preventDefault();" 
                            onclick="event.stopPropagation(); setLocationWithType(${index}, 'name')">장소명</button>
                    <button class="location-select-btn" style="padding: 2px 8px; font-size: 11px; border: 1px solid #2196F3; background: #2196F3; color: white; border-radius: 3px; cursor: pointer;" 
                            onmousedown="event.preventDefault();" 
                            onclick="event.stopPropagation(); setLocationWithType(${index}, 'address')">주소</button>
                </div>
            </div>
        </div>
    `).join('');
    
    dropdown.classList.add('show');
}

// 드롭다운 숨기기
function hideLocationDropdown() {
    const dropdown = document.getElementById('locationDropdown');
    if (dropdown) {
        dropdown.classList.remove('show');
    }
}

// 드롭다운에서 위치 선택 (타입 지정)
function setLocationWithType(index, type) {
    const items = document.querySelectorAll('.location-item');
    if (items[index]) {
        const data = JSON.parse(items[index].dataset.location);
        const locationInput = document.getElementById('locationInput');
        
        if (type === 'name') {
            // 장소명 선택
            locationInput.value = data.place_name;
        } else {
            // 주소 선택 (도로명 주소 우선, 없으면 지번 주소)
            locationInput.value = data.road_address_name || data.address_name;
        }
        
        // selectedLocationData에는 전체 정보와 선택 타입을 저장
        selectedLocationData = {
            ...data,
            display_type: type,  // 'name' 또는 'address'
            display_value: locationInput.value
        };
        
        hideLocationDropdown();
        
        console.log('위치 설정됨:', {
            type: type,
            display: locationInput.value,
            place_name: data.place_name,
            address: data.road_address_name || data.address_name
        });
        
        // 이동 박스 자동 업데이트 체크
        checkTransportBoxUpdate();
    }
}

// 드롭다운에서 위치 선택 (기존 함수 - 호환성 유지)
function setLocationFromDropdown(index) {
    setLocationWithType(index, 'address');  // 기본값은 주소
}

// 위치 설정
function setLocation(place) {
    const locationInput = document.getElementById('locationInput');
    if (locationInput) {
        // 도로명 주소가 있으면 도로명 주소를, 없으면 지번 주소를 사용
        const displayAddress = place.road_address_name || place.address_name;
        locationInput.value = displayAddress;
        
        // selectedLocationData에는 전체 정보를 저장 (place_name도 포함)
        selectedLocationData = {
            ...place,
            display_address: displayAddress  // 표시용 주소 추가
        };
        hideLocationDropdown();
        
        console.log('위치 설정됨:', {
            place_name: place.place_name,
            display_address: displayAddress,
            road_address: place.road_address_name,
            address: place.address_name,
            x: place.x,
            y: place.y
        });
        
        // 이동 박스 자동 업데이트 체크
        checkTransportBoxUpdate();
    }
}

// 위치 항목 선택
function selectLocationItem(item) {
    const items = document.querySelectorAll('.location-item');
    items.forEach(i => i.classList.remove('selected'));
    if (item) {
        item.classList.add('selected');
        item.scrollIntoView({ block: 'nearest' });
    }
}

// 일반 카테고리 UI 표시
function showRegularCategoryUI() {
    const boxCategory = document.getElementById('boxCategory');
    const transportMethod = document.getElementById('transportMethod');
    
    if (boxCategory) boxCategory.style.display = 'block';
    if (transportMethod) transportMethod.style.display = 'none';
    
    // 라벨 텍스트 변경
    const categoryLabel = document.querySelector('select#boxCategory')?.previousElementSibling;
    if (categoryLabel) {
        const labelText = categoryLabel.querySelector('span:last-child') || categoryLabel;
        if (labelText.textContent) labelText.textContent = '카테고리';
    }
}

// 이동박스 카테고리 UI 표시
function showTransportCategoryUI() {
    const boxCategory = document.getElementById('boxCategory');
    const transportMethod = document.getElementById('transportMethod');
    
    if (boxCategory) boxCategory.style.display = 'none';
    if (transportMethod) transportMethod.style.display = 'block';
    
    // 라벨 텍스트 변경
    const categoryLabel = document.querySelector('select#boxCategory')?.previousElementSibling;
    if (categoryLabel) {
        const labelText = categoryLabel.querySelector('span:last-child') || categoryLabel;
        if (labelText.textContent) labelText.textContent = '이동수단';
    }
}

// 이동 박스 업데이트 체크
function checkTransportBoxUpdate() {
    console.log('위치 선택됨:', selectedLocationData);
}

// 카테고리 변경 핸들러
function handleCategoryChange() {
    const category = document.getElementById('boxCategory').value;
    const categoryLabel = document.querySelector('label[for="boxCategory"]') || 
                         document.querySelector('select#boxCategory').previousElementSibling;
    const categoryContainer = document.getElementById('boxCategory').closest('div');
    
    if (category === 'transport') {
        // 카테고리를 "이동수단"으로 변경
        if (categoryLabel) {
            const labelText = categoryLabel.querySelector('span:last-child') || categoryLabel;
            labelText.textContent = '이동수단';
        }
        
        // 이동수단 드롭다운으로 교체
        const transportSelect = `
            <select id="transportMethod" style="width: 100%; padding: 7px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px;" onchange="handleTransportMethodChange()">
                <option value="TRANSIT">🚇 대중교통</option>
                <option value="DRIVING">🚗 자동차</option>
                <option value="WALKING">🚶 도보</option>
                <option value="BICYCLING">🚴 자전거</option>
            </select>
        `;
        document.getElementById('boxCategory').style.display = 'none';
        categoryContainer.insertAdjacentHTML('beforeend', transportSelect);
        
        // 이동박스 전용 UI 활성화
        showTransportUI();
    } else {
        // 일반 카테고리로 복원
        if (categoryLabel) {
            const labelText = categoryLabel.querySelector('span:last-child') || categoryLabel;
            labelText.textContent = '카테고리';
        }
        
        const transportMethod = document.getElementById('transportMethod');
        if (transportMethod) {
            transportMethod.remove();
        }
        document.getElementById('boxCategory').style.display = 'block';
        
        // 일반 UI로 복원
        hideTransportUI();
    }
}

// 현재 선택된 교통수단
let selectedTransportMethod = 'TRANSIT';

// 이동수단 변경 핸들러
function handleTransportMethodChange() {
    const method = document.getElementById('transportMethod').value;
    selectedTransportMethod = method;
    
    // 경로 재계산
    if (editingPlacedBox) {
        updateTransportRouteInfo();
    }
}

// 이동박스 UI 표시
function showTransportUI() {
    const routeInfo = document.getElementById('transportRouteInfo');
    const memo = document.getElementById('boxMemo');
    
    if (routeInfo) {
        routeInfo.style.display = 'block';
    }
    
    if (memo) {
        memo.placeholder = '이동 수단 상세 정보 (지하철 노선, 버스 번호, 주차 정보 등)';
    }
    
    // 스냅된 위치에서 경로 정보 업데이트
    updateTransportRouteInfo();
}

// 이동박스 UI 숨기기
function hideTransportUI() {
    const routeInfo = document.getElementById('transportRouteInfo');
    const memo = document.getElementById('boxMemo');
    
    if (routeInfo) {
        routeInfo.style.display = 'none';
    }
    
    if (memo) {
        memo.placeholder = '추가 정보나 팁을 입력하세요';
    }
}

// 이동박스 경로 정보 업데이트
function updateTransportRouteInfo() {
    let fromLocation = null;
    let toLocation = null;
    
    // 편집 중인 박스가 타임라인에 배치된 경우 인접 박스 확인
    if (editingPlacedBox) {
        const day = parseInt(editingPlacedBox.dataset.day);
        const boxesInDay = placedBoxes[day] || [];
        const currentIndex = boxesInDay.indexOf(editingPlacedBox);
        
        // 이전 박스와 다음 박스에서 위치 정보 찾기
        const prevBox = currentIndex > 0 ? boxesInDay[currentIndex - 1] : null;
        const nextBox = currentIndex < boxesInDay.length - 1 ? boxesInDay[currentIndex + 1] : null;
        
        if (prevBox && prevBox.dataset.locationData) {
            try {
                fromLocation = JSON.parse(prevBox.dataset.locationData);
            } catch (e) {
                console.error('이전 박스 위치 데이터 파싱 오류:', e);
            }
        }
        
        if (nextBox && nextBox.dataset.locationData) {
            try {
                toLocation = JSON.parse(nextBox.dataset.locationData);
            } catch (e) {
                console.error('다음 박스 위치 데이터 파싱 오류:', e);
            }
        }
    }
    
    // UI 업데이트
    const fromEl = document.getElementById('routeFromLocation');
    const toEl = document.getElementById('routeToLocation');
    
    if (fromEl) {
        fromEl.textContent = fromLocation ? fromLocation.place_name : '수동 입력';
        fromEl.style.color = fromLocation ? '#2196F3' : '#999';
    }
    
    if (toEl) {
        toEl.textContent = toLocation ? toLocation.place_name : '수동 입력';
        toEl.style.color = toLocation ? '#2196F3' : '#999';
    }
    
    // 두 위치가 모두 있으면 경로 계산
    if (fromLocation && toLocation) {
        calculateSimpleRoute(fromLocation, toLocation);
    } else {
        // 자동 계산 불가능한 상태
        document.getElementById('routeDistanceText').textContent = '수동 입력';
        document.getElementById('routeDurationText').textContent = '수동 입력';
    }
}

// 간단한 경로 계산
function calculateSimpleRoute(from, to) {
    const distance = calculateDistance(from.y, from.x, to.y, to.x);
    let estimatedTime, estimatedCost;
    
    switch (selectedTransportMethod) {
        case 'WALKING':
            estimatedTime = Math.round(distance * 12); // 1km당 12분
            estimatedCost = 0;
            break;
        case 'BICYCLING':
            estimatedTime = Math.round(distance * 4); // 1km당 4분
            estimatedCost = 0;
            break;
        case 'DRIVING':
            estimatedTime = Math.round(distance * 3); // 1km당 3분
            estimatedCost = Math.round(distance * 200); // 1km당 200원
            break;
        case 'TRANSIT':
        default:
            estimatedTime = Math.round(distance * 5); // 1km당 5분
            estimatedCost = Math.min(2500, Math.round(distance * 150));
            break;
    }
    
    // UI 업데이트
    document.getElementById('routeDistanceText').textContent = distance.toFixed(1) + 'km';
    document.getElementById('routeDurationText').textContent = estimatedTime + '분';
    
    // 소요시간을 duration 필드에도 반영
    const durationMinute = document.getElementById('durationMinute');
    if (durationMinute && estimatedTime >= 10) {
        const nearestOption = Array.from(durationMinute.options).find(option => 
            Math.abs(parseInt(option.value) - estimatedTime) <= 10
        );
        if (nearestOption) {
            durationMinute.value = nearestOption.value;
        }
    }
    
    // 예상 비용도 자동 입력 (비어있을 때만)
    const costInput = document.getElementById('boxCost');
    if (costInput && !costInput.value && estimatedCost > 0) {
        costInput.value = estimatedCost.toLocaleString() + '원';
    }
}

// 경로 상세 정보 표시 (지도 모달)
function showRouteDetails() {
    alert('경로 지도 기능은 준비 중입니다.\n\n교통수단: ' + getTransportMethodName(selectedTransportMethod) + 
          '\n거리: ' + document.getElementById('routeDistanceText').textContent +
          '\n소요시간: ' + document.getElementById('routeDurationText').textContent);
}

// 이동박스 전용 모달 표시
function showTransportModal(presetHour, presetMinute) {
    // 시간 셀렉트 초기화
    initializeTransportTimeSelects();
    
    // 기본값 설정
    if (presetHour !== undefined && presetMinute !== undefined) {
        document.getElementById('transportStartHour').value = presetHour;
        document.getElementById('transportStartMinute').value = presetMinute;
    } else {
        const now = new Date();
        const currentHour = now.getHours();
        if (currentHour >= 22 || currentHour < 6) {
            document.getElementById('transportStartHour').value = 9;
            document.getElementById('transportStartMinute').value = 0;
        } else {
            document.getElementById('transportStartHour').value = currentHour + 1;
            document.getElementById('transportStartMinute').value = 0;
        }
    }
    
    // 인접 박스에서 출발지/도착지 찾기
    findAdjacentLocations();
    
    // 모달 표시
    document.getElementById('transportModal').classList.add('show');
}

// 이동박스 모달 숨기기
function hideTransportModal() {
    document.getElementById('transportModal').classList.remove('show');
    clearTransportForm();
}

// 이동박스 시간 셀렉트 초기화
function initializeTransportTimeSelects() {
    const startHour = document.getElementById('transportStartHour');
    const startMinute = document.getElementById('transportStartMinute');
    
    startHour.innerHTML = '';
    for (let h = 0; h < 24; h++) {
        const option = document.createElement('option');
        option.value = h;
        option.textContent = h.toString().padStart(2, '0');
        startHour.appendChild(option);
    }
    
    startMinute.innerHTML = '';
    for (let m = 0; m < 60; m += 5) {
        const option = document.createElement('option');
        option.value = m;
        option.textContent = m.toString().padStart(2, '0');
        startMinute.appendChild(option);
    }
}

// 교통수단 선택
function selectTransportMethod(method) {
    selectedTransportMethod = method;
    
    // 버튼 스타일 업데이트
    document.querySelectorAll('.transport-method').forEach(btn => {
        const isActive = btn.dataset.method === method;
        btn.style.border = isActive ? '2px solid #2196F3' : '2px solid #e0e0e0';
        btn.style.background = isActive ? '#e3f2fd' : 'white';
        btn.querySelector('.material-icons').style.color = isActive ? '#2196F3' : '#666';
        btn.querySelector('div').style.color = isActive ? '#2196F3' : '#666';
        
        if (isActive) {
            btn.classList.add('active');
        } else {
            btn.classList.remove('active');
        }
    });
    
    // 선택된 교통수단으로 경로 재계산
    recalculateRoute();
}

// 인접 박스에서 위치 정보 찾기
function findAdjacentLocations() {
    let fromLocation = null;
    let toLocation = null;
    
    // 편집 중인 박스가 있는 경우
    if (editingPlacedBox) {
        const day = parseInt(editingPlacedBox.dataset.day);
        const boxesInDay = placedBoxes[day] || [];
        const currentIndex = boxesInDay.indexOf(editingPlacedBox);
        
        // 이전 박스와 다음 박스에서 위치 정보 찾기
        const prevBox = currentIndex > 0 ? boxesInDay[currentIndex - 1] : null;
        const nextBox = currentIndex < boxesInDay.length - 1 ? boxesInDay[currentIndex + 1] : null;
        
        if (prevBox && prevBox.dataset.locationData) {
            try {
                fromLocation = JSON.parse(prevBox.dataset.locationData);
            } catch (e) {
                console.error('이전 박스 위치 데이터 파싱 오류:', e);
            }
        }
        
        if (nextBox && nextBox.dataset.locationData) {
            try {
                toLocation = JSON.parse(nextBox.dataset.locationData);
            } catch (e) {
                console.error('다음 박스 위치 데이터 파싱 오류:', e);
            }
        }
    }
    
    // UI 업데이트
    document.getElementById('fromLocation').textContent = fromLocation ? fromLocation.place_name : '-';
    document.getElementById('toLocation').textContent = toLocation ? toLocation.place_name : '-';
    
    // 두 위치가 모두 있으면 경로 계산
    if (fromLocation && toLocation) {
        calculateTransportRoute(fromLocation, toLocation);
    } else {
        // 경로 정보 숨기기
        document.getElementById('routeResults').style.display = 'none';
    }
}

// 경로 재계산
function recalculateRoute() {
    const fromText = document.getElementById('fromLocation').textContent;
    const toText = document.getElementById('toLocation').textContent;
    
    if (fromText !== '-' && toText !== '-') {
        // 실제 위치 데이터로 재계산 필요
        findAdjacentLocations();
    }
}

// 이동박스 경로 계산
function calculateTransportRoute(from, to) {
    console.log('이동박스 경로 계산:', from.place_name, '→', to.place_name, '교통수단:', selectedTransportMethod);
    
    // TODO: 카카오 Mobility API 연동
    // 현재는 임시 계산
    const distance = calculateDistance(from.y, from.x, to.y, to.x);
    let estimatedTime, estimatedCost;
    
    switch (selectedTransportMethod) {
        case 'WALKING':
            estimatedTime = Math.round(distance * 12); // 1km당 12분
            estimatedCost = 0;
            break;
        case 'BICYCLING':
            estimatedTime = Math.round(distance * 4); // 1km당 4분
            estimatedCost = 0;
            break;
        case 'DRIVING':
            estimatedTime = Math.round(distance * 3); // 1km당 3분
            estimatedCost = Math.round(distance * 200); // 1km당 200원 (주차비 포함)
            break;
        case 'TRANSIT':
        default:
            estimatedTime = Math.round(distance * 5); // 1km당 5분
            estimatedCost = Math.min(2500, Math.round(distance * 150)); // 기본 2500원, 거리별 추가
            break;
    }
    
    // 결과 표시
    document.getElementById('routeDistance').textContent = distance.toFixed(1) + 'km';
    document.getElementById('routeDuration').textContent = estimatedTime + '분';
    document.getElementById('routeCost').textContent = estimatedCost.toLocaleString() + '원';
    document.getElementById('routeResults').style.display = 'block';
    
    // 예상 비용 필드에도 자동 입력
    document.getElementById('transportCost').value = estimatedCost.toLocaleString() + '원';
}

// 이동박스 폼 초기화
function clearTransportForm() {
    document.getElementById('transportCost').value = '';
    document.getElementById('transportMemo').value = '';
    document.getElementById('fromLocation').textContent = '-';
    document.getElementById('toLocation').textContent = '-';
    document.getElementById('routeResults').style.display = 'none';
}

// 이동박스 저장
function saveTransportBox() {
    const startHour = document.getElementById('transportStartHour').value;
    const startMinute = document.getElementById('transportStartMinute').value;
    const cost = document.getElementById('transportCost').value;
    const memo = document.getElementById('transportMemo').value;
    
    const boxData = {
        id: editingBoxId || Date.now(),
        title: '이동',
        startHour: parseInt(startHour) || 9,
        startMinute: parseInt(startMinute) || 0,
        durationHour: 0,
        durationMinute: Math.max(10, parseInt(document.getElementById('routeDuration').textContent) || 30),
        category: 'transport',
        cost: cost,
        memo: memo,
        transportMethod: selectedTransportMethod,
        hasTimeSet: true
    };
    
    // 기존 플랜박스 저장 로직 재사용
    if (editingBoxId) {
        // 수정 모드
        const existingIndex = planboxData.findIndex(p => p.id === editingBoxId);
        if (existingIndex !== -1) {
            planboxData[existingIndex] = boxData;
        }
    } else {
        // 새로 추가
        planboxData.push(boxData);
    }
    
    renderPlanboxList();
    saveToLocalStorage();
    hideTransportModal();
}

// 경로 지도 보기
function showRouteOnMap() {
    alert('경로 지도 기능은 준비 중입니다.\n선택한 교통수단: ' + getTransportMethodName(selectedTransportMethod));
}

// 교통수단 이름 가져오기
function getTransportMethodName(method) {
    const names = {
        'TRANSIT': '대중교통',
        'DRIVING': '자동차',
        'WALKING': '도보',
        'BICYCLING': '자전거'
    };
    return names[method] || '대중교통';
}

// 이동박스 삭제
function deleteTransportFromModal() {
    if (editingPlacedBox) {
        showConfirm('이 이동 계획을 삭제하시겠습니까?', () => {
            removePlacedBox(editingPlacedBox);
            hideTransportModal();
        });
    }
}

// 인접 박스의 위치 정보 확인 및 경로 계산
function checkAdjacentBoxesForRoute() {
    if (!editingPlacedBox) return;
    
    const day = parseInt(editingPlacedBox.dataset.day);
    const boxesInDay = placedBoxes[day] || [];
    const currentIndex = boxesInDay.indexOf(editingPlacedBox);
    
    if (currentIndex === -1) return;
    
    // 이전 박스와 다음 박스 찾기
    const prevBox = currentIndex > 0 ? boxesInDay[currentIndex - 1] : null;
    const nextBox = currentIndex < boxesInDay.length - 1 ? boxesInDay[currentIndex + 1] : null;
    
    // 위치 정보가 있는 박스들 찾기
    let fromLocation = null;
    let toLocation = null;
    
    if (prevBox && prevBox.dataset.locationData) {
        fromLocation = JSON.parse(prevBox.dataset.locationData);
    }
    
    if (nextBox && nextBox.dataset.locationData) {
        toLocation = JSON.parse(nextBox.dataset.locationData);
    }
    
    // 두 위치가 모두 있으면 경로 계산
    if (fromLocation && toLocation) {
        calculateRoute(fromLocation, toLocation);
    }
}

// 경로 계산 (카카오 Mobility API 사용 예정)
function calculateRoute(from, to) {
    console.log('경로 계산:', from.place_name, '→', to.place_name);
    
    // TODO: 카카오 Mobility API 연동
    // 현재는 직선 거리와 예상 시간만 계산
    const distance = calculateDistance(from.y, from.x, to.y, to.x);
    const estimatedTime = Math.round(distance * 2); // 임시: 1km당 2분
    
    // 메모 필드에 자동으로 정보 입력
    const memoField = document.getElementById('boxMemo');
    if (memoField) {
        memoField.value = `${from.place_name} → ${to.place_name}\n거리: ${distance.toFixed(1)}km\n예상 시간: ${estimatedTime}분`;
    }
}

// 두 지점 간 거리 계산 (Haversine formula)
function calculateDistance(lat1, lon1, lat2, lon2) {
    const R = 6371; // 지구 반경 (km)
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
              Math.sin(dLon/2) * Math.sin(dLon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
}

// 카카오맵 API 동적 로드
let kakaoMapLoaded = false;
let kakaoMapLoading = false;

function loadKakaoMapAPI(callback) {
    if (kakaoMapLoaded) {
        callback();
        return;
    }
    
    if (kakaoMapLoading) {
        // 이미 로딩 중이면 기다림
        const checkInterval = setInterval(() => {
            if (kakaoMapLoaded) {
                clearInterval(checkInterval);
                callback();
            }
        }, 100);
        return;
    }
    
    kakaoMapLoading = true;
    
    const script = document.createElement('script');
    script.type = 'text/javascript';
    // 로컬 파일 실행 감지
    const isLocalFile = window.location.protocol === 'file:';
    if (isLocalFile) {
        alert('카카오맵을 사용하려면 로컬 서버가 필요합니다.\n\n1. start_server.bat 파일을 실행하세요\n2. 브라우저에서 http://localhost:3000 으로 접속하세요');
        kakaoMapLoading = false;
        return;
    }
    
    script.src = 'https://dapi.kakao.com/v2/maps/sdk.js?appkey=d0d67d94afae47e0ab9c29b0e6aea5cf&libraries=services&autoload=false';
    
    script.onload = function() {
        kakao.maps.load(function() {
            kakaoMapLoaded = true;
            kakaoMapLoading = false;
            console.log('카카오맵 API 로드 완료');
            callback();
        });
    };
    
    script.onerror = function() {
        kakaoMapLoading = false;
        console.error('카카오맵 API 로드 실패');
        alert('지도 서비스를 불러오는데 실패했습니다.');
    };
    
    document.head.appendChild(script);
}

// 지도 모달 열기
function openMapModal() {
    // 지도 모달이 없으면 생성
    let mapModal = document.getElementById('mapModal');
    if (!mapModal) {
        createMapModal();
        mapModal = document.getElementById('mapModal');
    }
    
    // 모달 표시
    mapModal.classList.add('show');
    
    // 카카오맵 API 로드 후 초기화
    loadKakaoMapAPI(() => {
        initializeKakaoMap();
    });
}

// 지도 모달 생성
function createMapModal() {
    const modalHTML = `
        <div id="mapModal" class="modal-backdrop" onclick="if(event.target === this) closeMapModal()">
            <div class="map-modal-container">
                <div class="map-modal-header">
                    <h3>장소 검색</h3>
                    <button type="button" class="close-btn" onclick="closeMapModal(); return false;">
                        <span class="material-icons">close</span>
                    </button>
                </div>
                <div class="map-search-container">
                    <input type="text" id="mapSearchInput" placeholder="장소명 또는 주소를 입력하세요">
                    <button onclick="searchPlace()" class="search-btn">
                        <span class="material-icons">search</span>
                    </button>
                </div>
                <div id="map" style="width: 100%; height: 500px;"></div>
                <div class="map-modal-footer">
                    <div id="selectedAddress">선택된 장소가 없습니다</div>
                    <button onclick="confirmLocation()" class="confirm-btn">선택 완료</button>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
    
    // ESC 키로 닫기 - 전역 이벤트 리스너 한 번만 추가
    if (!window.mapModalEscListener) {
        window.mapModalEscListener = function(e) {
            if (e.key === 'Escape') {
                const mapModal = document.getElementById('mapModal');
                if (mapModal && mapModal.classList.contains('show')) {
                    closeMapModal();
                }
            }
        };
        document.addEventListener('keydown', window.mapModalEscListener);
    }
}

// 카카오맵 초기화
let map = null;
let markers = [];
let selectedPlace = null;
let ps = null;
let infowindow = null;

function initializeKakaoMap() {
    const mapContainer = document.getElementById('map');
    
    if (!mapContainer) {
        console.error('지도 컨테이너를 찾을 수 없습니다.');
        return;
    }
    
    // 이미 초기화된 경우 기존 맵 재사용
    if (map) {
        console.log('기존 맵 재사용');
        // 중심 위치 재설정
        map.setCenter(new kakao.maps.LatLng(37.566826, 126.9786567));
        return;
    }
    
    try {
        const mapOption = {
            center: new kakao.maps.LatLng(37.566826, 126.9786567), // 서울시청 좌표
            level: 3
        };
        
        map = new kakao.maps.Map(mapContainer, mapOption);
        ps = new kakao.maps.services.Places();
        infowindow = new kakao.maps.InfoWindow({zIndex: 1});
        
        console.log('카카오맵 초기화 성공');
        console.log('ps 객체:', ps);
        
        // 엔터키로 검색
        const searchInput = document.getElementById('mapSearchInput');
        if (searchInput) {
            searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    searchPlace();
                }
            });
        }
    } catch (error) {
        console.error('카카오맵 초기화 중 오류:', error);
        alert('지도 초기화 중 오류가 발생했습니다.');
    }
}

// 장소 검색
function searchPlace() {
    const keyword = document.getElementById('mapSearchInput').value;
    
    if (!keyword.trim()) {
        alert('검색어를 입력해주세요!');
        return;
    }
    
    // ps가 초기화되지 않은 경우 처리
    if (!ps) {
        console.error('Places 서비스가 초기화되지 않았습니다.');
        alert('지도가 아직 로드되지 않았습니다. 잠시 후 다시 시도해주세요.');
        return;
    }
    
    // 키워드로 장소 검색
    ps.keywordSearch(keyword, placesSearchCB);
}

// 검색 결과 콜백
function placesSearchCB(data, status, pagination) {
    if (status === kakao.maps.services.Status.OK) {
        // 기존 마커 제거
        removeMarkers();
        
        // 검색 결과 표시
        displayPlaces(data);
        
        // 지도 범위 재설정
        const bounds = new kakao.maps.LatLngBounds();
        for (let i = 0; i < data.length; i++) {
            bounds.extend(new kakao.maps.LatLng(data[i].y, data[i].x));
        }
        map.setBounds(bounds);
    } else if (status === kakao.maps.services.Status.ZERO_RESULT) {
        alert('검색 결과가 없습니다.');
    } else if (status === kakao.maps.services.Status.ERROR) {
        alert('검색 중 오류가 발생했습니다.');
    }
}

// 검색 결과 표시
function displayPlaces(places) {
    for (let i = 0; i < places.length; i++) {
        const placePosition = new kakao.maps.LatLng(places[i].y, places[i].x);
        const marker = addMarker(placePosition, i);
        const place = places[i];
        
        // 마커 클릭 이벤트
        kakao.maps.event.addListener(marker, 'click', function() {
            displayInfowindow(marker, place);
            selectPlace(place);
        });
    }
}

// 마커 추가
function addMarker(position, idx) {
    const imageSrc = 'https://t1.daumcdn.net/localimg/localimages/07/mapapidoc/marker_number_blue.png';
    const imageSize = new kakao.maps.Size(36, 37);
    const imgOptions = {
        spriteSize: new kakao.maps.Size(36, 691),
        spriteOrigin: new kakao.maps.Point(0, (idx * 46) + 10),
        offset: new kakao.maps.Point(13, 37)
    };
    const markerImage = new kakao.maps.MarkerImage(imageSrc, imageSize, imgOptions);
    const marker = new kakao.maps.Marker({
        position: position,
        image: markerImage
    });
    
    marker.setMap(map);
    markers.push(marker);
    
    return marker;
}

// 마커 제거
function removeMarkers() {
    for (let i = 0; i < markers.length; i++) {
        markers[i].setMap(null);
    }
    markers = [];
}

// 인포윈도우 표시
function displayInfowindow(marker, place) {
    const content = '<div style="padding:5px;font-size:12px;">' + place.place_name + '</div>';
    infowindow.setContent(content);
    infowindow.open(map, marker);
}

// 장소 선택
function selectPlace(place) {
    selectedPlace = place;
    const addressEl = document.getElementById('selectedAddress');
    if (addressEl) {
        addressEl.innerHTML = `<strong>${place.place_name}</strong><br>${place.road_address_name || place.address_name}`;
    }
}

// 위치 확정
function confirmLocation() {
    if (!selectedPlace) {
        alert('장소를 선택해주세요.');
        return;
    }
    
    // 위치 입력 필드에 값 설정
    const locationInput = document.getElementById('locationInput');
    if (locationInput) {
        locationInput.value = selectedPlace.place_name;
    }
    
    // 모달 닫기
    closeMapModal();
}

// 지도 모달 닫기
function closeMapModal() {
    const mapModal = document.getElementById('mapModal');
    if (mapModal) {
        mapModal.classList.remove('show');
        // 모달 완전히 제거
        setTimeout(() => {
            mapModal.remove();
            // 맵 관련 변수 초기화
            map = null;
            ps = null;
            infowindow = null;
            markers = [];
            selectedPlace = null;
        }, 300);
    }
    
    // 검색 초기화
    const searchInput = document.getElementById('mapSearchInput');
    if (searchInput) {
        searchInput.value = '';
    }
    
    // 선택 초기화
    selectedPlace = null;
    const addressEl = document.getElementById('selectedAddress');
    if (addressEl) {
        addressEl.textContent = '선택된 장소가 없습니다';
    }
    
}
    </script>
</body>
</html>